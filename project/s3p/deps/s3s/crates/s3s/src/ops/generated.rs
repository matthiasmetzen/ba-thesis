//! Auto generated by `codegen/src/ops.rs`

#![allow(clippy::declare_interior_mutable_const)]
#![allow(clippy::borrow_interior_mutable_const)]
#![allow(clippy::needless_pass_by_value)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::unnecessary_wraps)]

use crate::dto::*;
use crate::error::*;
use crate::header::*;
use crate::http;
use crate::path::S3Path;
use crate::s3_trait::S3;
use crate::{S3Request, S3Response};

use std::borrow::Cow;
use std::sync::Arc;

impl http::TryIntoHeaderValue for ArchiveStatus {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for BucketCannedACL {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ChecksumAlgorithm {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ChecksumMode {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for MetadataDirective {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ObjectAttributes {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ObjectCannedACL {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ObjectLockLegalHoldStatus {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ObjectLockMode {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ObjectOwnership {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ReplicationStatus {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for RequestCharged {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for RequestPayer {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for ServerSideEncryption {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for StorageClass {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryIntoHeaderValue for TaggingDirective {
    type Error = http::InvalidHeaderValue;
    fn try_into_header_value(self) -> Result<http::HeaderValue, Self::Error> {
        match Cow::from(self) {
            Cow::Borrowed(s) => http::HeaderValue::try_from(s),
            Cow::Owned(s) => http::HeaderValue::try_from(s),
        }
    }
}

impl http::TryFromHeaderValue for ArchiveStatus {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for BucketCannedACL {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ChecksumAlgorithm {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ChecksumMode {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for MetadataDirective {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ObjectAttributes {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ObjectCannedACL {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ObjectLockLegalHoldStatus {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ObjectLockMode {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ObjectOwnership {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ReplicationStatus {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for RequestCharged {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for RequestPayer {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for ServerSideEncryption {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for StorageClass {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

impl http::TryFromHeaderValue for TaggingDirective {
    type Error = http::ParseHeaderError;
    fn try_from_header_value(val: &http::HeaderValue) -> Result<Self, Self::Error> {
        let val = val.to_str().map_err(|_| http::ParseHeaderError::Enum)?;
        Ok(Self::from(val.to_owned()))
    }
}

pub struct AbortMultipartUpload;

impl AbortMultipartUpload {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<AbortMultipartUploadInput> {
        AbortMultipartUploadInput::try_from(req)
    }

    pub fn serialize_http(x: AbortMultipartUploadOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for AbortMultipartUpload {
    fn name(&self) -> &'static str {
        "AbortMultipartUpload"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.abort_multipart_upload(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for AbortMultipartUpload {
    type Input = AbortMultipartUploadInput;
    type Output = AbortMultipartUploadOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.abort_multipart_upload(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for AbortMultipartUploadInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let upload_id: MultipartUploadId = http::parse_query(req, "uploadId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
            upload_id,
        })
    }
}

impl TryInto<http::Response> for AbortMultipartUploadOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::NO_CONTENT);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct CompleteMultipartUpload;

impl CompleteMultipartUpload {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<CompleteMultipartUploadInput> {
        CompleteMultipartUploadInput::try_from(req)
    }

    pub fn serialize_http(x: CompleteMultipartUploadOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for CompleteMultipartUpload {
    fn name(&self) -> &'static str {
        "CompleteMultipartUpload"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.complete_multipart_upload(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for CompleteMultipartUpload {
    type Input = CompleteMultipartUploadInput;
    type Output = CompleteMultipartUploadOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.complete_multipart_upload(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for CompleteMultipartUploadInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_crc32: Option<ChecksumCRC32> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32)?;

        let checksum_crc32c: Option<ChecksumCRC32C> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32C)?;

        let checksum_sha1: Option<ChecksumSHA1> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA1)?;

        let checksum_sha256: Option<ChecksumSHA256> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA256)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let multipart_upload: Option<CompletedMultipartUpload> = http::take_opt_xml_body(req)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let upload_id: MultipartUploadId = http::parse_query(req, "uploadId")?;

        Ok(Self {
            bucket,
            checksum_crc32,
            checksum_crc32c,
            checksum_sha1,
            checksum_sha256,
            expected_bucket_owner,
            key,
            multipart_upload,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            upload_id,
        })
    }
}

impl TryInto<http::Response> for CompleteMultipartUploadOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_EXPIRATION, self.expiration)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct CopyObject;

impl CopyObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<CopyObjectInput> {
        CopyObjectInput::try_from(req)
    }

    pub fn serialize_http(x: CopyObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for CopyObject {
    fn name(&self) -> &'static str {
        "CopyObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.copy_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for CopyObject {
    type Input = CopyObjectInput;
    type Output = CopyObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.copy_object(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for CopyObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let acl: Option<ObjectCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let bucket_key_enabled: Option<BucketKeyEnabled> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED)?;

        let cache_control: Option<CacheControl> = http::parse_opt_header(req, &CACHE_CONTROL)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_ALGORITHM)?;

        let content_disposition: Option<ContentDisposition> = http::parse_opt_header(req, &CONTENT_DISPOSITION)?;

        let content_encoding: Option<ContentEncoding> = http::parse_opt_header(req, &CONTENT_ENCODING)?;

        let content_language: Option<ContentLanguage> = http::parse_opt_header(req, &CONTENT_LANGUAGE)?;

        let content_type: Option<ContentType> = http::parse_opt_header(req, &CONTENT_TYPE)?;

        let copy_source: CopySource = http::parse_header(req, &X_AMZ_COPY_SOURCE)?;

        let copy_source_if_match: Option<CopySourceIfMatch> = http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_IF_MATCH)?;

        let copy_source_if_modified_since: Option<CopySourceIfModifiedSince> =
            http::parse_opt_header_timestamp(req, &X_AMZ_COPY_SOURCE_IF_MODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let copy_source_if_none_match: Option<CopySourceIfNoneMatch> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_IF_NONE_MATCH)?;

        let copy_source_if_unmodified_since: Option<CopySourceIfUnmodifiedSince> =
            http::parse_opt_header_timestamp(req, &X_AMZ_COPY_SOURCE_IF_UNMODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let copy_source_sse_customer_algorithm: Option<CopySourceSSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let copy_source_sse_customer_key: Option<CopySourceSSECustomerKey> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let copy_source_sse_customer_key_md5: Option<CopySourceSSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let expected_source_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_SOURCE_EXPECTED_BUCKET_OWNER)?;

        let expires: Option<Expires> = http::parse_opt_header_timestamp(req, &EXPIRES, TimestampFormat::HttpDate)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        let metadata: Option<Metadata> = http::parse_opt_metadata(req)?;

        let metadata_directive: Option<MetadataDirective> = http::parse_opt_header(req, &X_AMZ_METADATA_DIRECTIVE)?;

        let object_lock_legal_hold_status: Option<ObjectLockLegalHoldStatus> =
            http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_LEGAL_HOLD)?;

        let object_lock_mode: Option<ObjectLockMode> = http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_MODE)?;

        let object_lock_retain_until_date: Option<ObjectLockRetainUntilDate> =
            http::parse_opt_header_timestamp(req, &X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE, TimestampFormat::DateTime)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let ssekms_encryption_context: Option<SSEKMSEncryptionContext> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT)?;

        let ssekms_key_id: Option<SSEKMSKeyId> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID)?;

        let server_side_encryption: Option<ServerSideEncryption> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION)?;

        let storage_class: Option<StorageClass> = http::parse_opt_header(req, &X_AMZ_STORAGE_CLASS)?;

        let tagging: Option<TaggingHeader> = http::parse_opt_header(req, &X_AMZ_TAGGING)?;

        let tagging_directive: Option<TaggingDirective> = http::parse_opt_header(req, &X_AMZ_TAGGING_DIRECTIVE)?;

        let website_redirect_location: Option<WebsiteRedirectLocation> =
            http::parse_opt_header(req, &X_AMZ_WEBSITE_REDIRECT_LOCATION)?;

        Ok(Self {
            acl,
            bucket,
            bucket_key_enabled,
            cache_control,
            checksum_algorithm,
            content_disposition,
            content_encoding,
            content_language,
            content_type,
            copy_source,
            copy_source_if_match,
            copy_source_if_modified_since,
            copy_source_if_none_match,
            copy_source_if_unmodified_since,
            copy_source_sse_customer_algorithm,
            copy_source_sse_customer_key,
            copy_source_sse_customer_key_md5,
            expected_bucket_owner,
            expected_source_bucket_owner,
            expires,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write_acp,
            key,
            metadata,
            metadata_directive,
            object_lock_legal_hold_status,
            object_lock_mode,
            object_lock_retain_until_date,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            ssekms_encryption_context,
            ssekms_key_id,
            server_side_encryption,
            storage_class,
            tagging,
            tagging_directive,
            website_redirect_location,
        })
    }
}

impl TryInto<http::Response> for CopyObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.copy_object_result {
            http::set_xml_body(&mut res, val)?;
        }
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_COPY_SOURCE_VERSION_ID, self.copy_source_version_id)?;
        http::add_opt_header(&mut res, X_AMZ_EXPIRATION, self.expiration)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT, self.ssekms_encryption_context)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct CreateBucket;

impl CreateBucket {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<CreateBucketInput> {
        CreateBucketInput::try_from(req)
    }

    pub fn serialize_http(x: CreateBucketOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for CreateBucket {
    fn name(&self) -> &'static str {
        "CreateBucket"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.create_bucket(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for CreateBucket {
    type Input = CreateBucketInput;
    type Output = CreateBucketOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.create_bucket(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for CreateBucketInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let acl: Option<BucketCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let create_bucket_configuration: Option<CreateBucketConfiguration> = http::take_opt_xml_body(req)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write: Option<GrantWrite> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        let object_lock_enabled_for_bucket: Option<ObjectLockEnabledForBucket> =
            http::parse_opt_header(req, &X_AMZ_BUCKET_OBJECT_LOCK_ENABLED)?;

        let object_ownership: Option<ObjectOwnership> = http::parse_opt_header(req, &X_AMZ_OBJECT_OWNERSHIP)?;

        Ok(Self {
            acl,
            bucket,
            create_bucket_configuration,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write,
            grant_write_acp,
            object_lock_enabled_for_bucket,
            object_ownership,
        })
    }
}

impl TryInto<http::Response> for CreateBucketOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, LOCATION, self.location)?;
        Ok(res)
    }
}

pub struct CreateMultipartUpload;

impl CreateMultipartUpload {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<CreateMultipartUploadInput> {
        CreateMultipartUploadInput::try_from(req)
    }

    pub fn serialize_http(x: CreateMultipartUploadOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for CreateMultipartUpload {
    fn name(&self) -> &'static str {
        "CreateMultipartUpload"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.create_multipart_upload(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for CreateMultipartUpload {
    type Input = CreateMultipartUploadInput;
    type Output = CreateMultipartUploadOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.create_multipart_upload(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for CreateMultipartUploadInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let acl: Option<ObjectCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let bucket_key_enabled: Option<BucketKeyEnabled> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED)?;

        let cache_control: Option<CacheControl> = http::parse_opt_header(req, &CACHE_CONTROL)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_ALGORITHM)?;

        let content_disposition: Option<ContentDisposition> = http::parse_opt_header(req, &CONTENT_DISPOSITION)?;

        let content_encoding: Option<ContentEncoding> = http::parse_opt_header(req, &CONTENT_ENCODING)?;

        let content_language: Option<ContentLanguage> = http::parse_opt_header(req, &CONTENT_LANGUAGE)?;

        let content_type: Option<ContentType> = http::parse_opt_header(req, &CONTENT_TYPE)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let expires: Option<Expires> = http::parse_opt_header_timestamp(req, &EXPIRES, TimestampFormat::HttpDate)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        let metadata: Option<Metadata> = http::parse_opt_metadata(req)?;

        let object_lock_legal_hold_status: Option<ObjectLockLegalHoldStatus> =
            http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_LEGAL_HOLD)?;

        let object_lock_mode: Option<ObjectLockMode> = http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_MODE)?;

        let object_lock_retain_until_date: Option<ObjectLockRetainUntilDate> =
            http::parse_opt_header_timestamp(req, &X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE, TimestampFormat::DateTime)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let ssekms_encryption_context: Option<SSEKMSEncryptionContext> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT)?;

        let ssekms_key_id: Option<SSEKMSKeyId> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID)?;

        let server_side_encryption: Option<ServerSideEncryption> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION)?;

        let storage_class: Option<StorageClass> = http::parse_opt_header(req, &X_AMZ_STORAGE_CLASS)?;

        let tagging: Option<TaggingHeader> = http::parse_opt_header(req, &X_AMZ_TAGGING)?;

        let website_redirect_location: Option<WebsiteRedirectLocation> =
            http::parse_opt_header(req, &X_AMZ_WEBSITE_REDIRECT_LOCATION)?;

        Ok(Self {
            acl,
            bucket,
            bucket_key_enabled,
            cache_control,
            checksum_algorithm,
            content_disposition,
            content_encoding,
            content_language,
            content_type,
            expected_bucket_owner,
            expires,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write_acp,
            key,
            metadata,
            object_lock_legal_hold_status,
            object_lock_mode,
            object_lock_retain_until_date,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            ssekms_encryption_context,
            ssekms_key_id,
            server_side_encryption,
            storage_class,
            tagging,
            website_redirect_location,
        })
    }
}

impl TryInto<http::Response> for CreateMultipartUploadOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_opt_header_timestamp(&mut res, X_AMZ_ABORT_DATE, self.abort_date, TimestampFormat::HttpDate)?;
        http::add_opt_header(&mut res, X_AMZ_ABORT_RULE_ID, self.abort_rule_id)?;
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_ALGORITHM, self.checksum_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT, self.ssekms_encryption_context)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        Ok(res)
    }
}

pub struct DeleteBucket;

impl DeleteBucket {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketInput> {
        DeleteBucketInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucket {
    fn name(&self) -> &'static str {
        "DeleteBucket"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucket {
    type Input = DeleteBucketInput;
    type Output = DeleteBucketOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketAnalyticsConfiguration;

impl DeleteBucketAnalyticsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketAnalyticsConfigurationInput> {
        DeleteBucketAnalyticsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketAnalyticsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketAnalyticsConfiguration {
    fn name(&self) -> &'static str {
        "DeleteBucketAnalyticsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_analytics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketAnalyticsConfiguration {
    type Input = DeleteBucketAnalyticsConfigurationInput;
    type Output = DeleteBucketAnalyticsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_analytics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketAnalyticsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: AnalyticsId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketAnalyticsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketCors;

impl DeleteBucketCors {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketCorsInput> {
        DeleteBucketCorsInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketCorsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketCors {
    fn name(&self) -> &'static str {
        "DeleteBucketCors"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_cors(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketCors {
    type Input = DeleteBucketCorsInput;
    type Output = DeleteBucketCorsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_cors(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketCorsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketCorsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketEncryption;

impl DeleteBucketEncryption {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketEncryptionInput> {
        DeleteBucketEncryptionInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketEncryptionOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketEncryption {
    fn name(&self) -> &'static str {
        "DeleteBucketEncryption"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_encryption(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketEncryption {
    type Input = DeleteBucketEncryptionInput;
    type Output = DeleteBucketEncryptionOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_encryption(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketEncryptionInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketEncryptionOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketIntelligentTieringConfiguration;

impl DeleteBucketIntelligentTieringConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketIntelligentTieringConfigurationInput> {
        DeleteBucketIntelligentTieringConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketIntelligentTieringConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketIntelligentTieringConfiguration {
    fn name(&self) -> &'static str {
        "DeleteBucketIntelligentTieringConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_intelligent_tiering_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketIntelligentTieringConfiguration {
    type Input = DeleteBucketIntelligentTieringConfigurationInput;
    type Output = DeleteBucketIntelligentTieringConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_intelligent_tiering_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketIntelligentTieringConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let id: IntelligentTieringId = http::parse_query(req, "id")?;

        Ok(Self { bucket, id })
    }
}

impl TryInto<http::Response> for DeleteBucketIntelligentTieringConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketInventoryConfiguration;

impl DeleteBucketInventoryConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketInventoryConfigurationInput> {
        DeleteBucketInventoryConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketInventoryConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketInventoryConfiguration {
    fn name(&self) -> &'static str {
        "DeleteBucketInventoryConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_inventory_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketInventoryConfiguration {
    type Input = DeleteBucketInventoryConfigurationInput;
    type Output = DeleteBucketInventoryConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_inventory_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketInventoryConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: InventoryId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketInventoryConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketLifecycle;

impl DeleteBucketLifecycle {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketLifecycleInput> {
        DeleteBucketLifecycleInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketLifecycleOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketLifecycle {
    fn name(&self) -> &'static str {
        "DeleteBucketLifecycle"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_lifecycle(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketLifecycle {
    type Input = DeleteBucketLifecycleInput;
    type Output = DeleteBucketLifecycleOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_lifecycle(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketLifecycleInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketLifecycleOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketMetricsConfiguration;

impl DeleteBucketMetricsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketMetricsConfigurationInput> {
        DeleteBucketMetricsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketMetricsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketMetricsConfiguration {
    fn name(&self) -> &'static str {
        "DeleteBucketMetricsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_metrics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketMetricsConfiguration {
    type Input = DeleteBucketMetricsConfigurationInput;
    type Output = DeleteBucketMetricsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_metrics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketMetricsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: MetricsId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketMetricsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketOwnershipControls;

impl DeleteBucketOwnershipControls {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketOwnershipControlsInput> {
        DeleteBucketOwnershipControlsInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketOwnershipControlsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketOwnershipControls {
    fn name(&self) -> &'static str {
        "DeleteBucketOwnershipControls"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_ownership_controls(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketOwnershipControls {
    type Input = DeleteBucketOwnershipControlsInput;
    type Output = DeleteBucketOwnershipControlsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_ownership_controls(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketOwnershipControlsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketOwnershipControlsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketPolicy;

impl DeleteBucketPolicy {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketPolicyInput> {
        DeleteBucketPolicyInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketPolicyOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketPolicy {
    fn name(&self) -> &'static str {
        "DeleteBucketPolicy"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_policy(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketPolicy {
    type Input = DeleteBucketPolicyInput;
    type Output = DeleteBucketPolicyOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_policy(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketPolicyInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketPolicyOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketReplication;

impl DeleteBucketReplication {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketReplicationInput> {
        DeleteBucketReplicationInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketReplicationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketReplication {
    fn name(&self) -> &'static str {
        "DeleteBucketReplication"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_replication(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketReplication {
    type Input = DeleteBucketReplicationInput;
    type Output = DeleteBucketReplicationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_replication(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketReplicationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketReplicationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketTagging;

impl DeleteBucketTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketTaggingInput> {
        DeleteBucketTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketTagging {
    fn name(&self) -> &'static str {
        "DeleteBucketTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketTagging {
    type Input = DeleteBucketTaggingInput;
    type Output = DeleteBucketTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteBucketWebsite;

impl DeleteBucketWebsite {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteBucketWebsiteInput> {
        DeleteBucketWebsiteInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteBucketWebsiteOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteBucketWebsite {
    fn name(&self) -> &'static str {
        "DeleteBucketWebsite"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_bucket_website(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteBucketWebsite {
    type Input = DeleteBucketWebsiteInput;
    type Output = DeleteBucketWebsiteOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_bucket_website(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteBucketWebsiteInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeleteBucketWebsiteOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct DeleteObject;

impl DeleteObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteObjectInput> {
        DeleteObjectInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteObject {
    fn name(&self) -> &'static str {
        "DeleteObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteObject {
    type Input = DeleteObjectInput;
    type Output = DeleteObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_object(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let bypass_governance_retention: Option<BypassGovernanceRetention> =
            http::parse_opt_header(req, &X_AMZ_BYPASS_GOVERNANCE_RETENTION)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let mfa: Option<MFA> = http::parse_opt_header(req, &X_AMZ_MFA)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            bypass_governance_retention,
            expected_bucket_owner,
            key,
            mfa,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for DeleteObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::NO_CONTENT);
        http::add_header(&mut res, X_AMZ_DELETE_MARKER, self.delete_marker)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct DeleteObjectTagging;

impl DeleteObjectTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteObjectTaggingInput> {
        DeleteObjectTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteObjectTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteObjectTagging {
    fn name(&self) -> &'static str {
        "DeleteObjectTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_object_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteObjectTagging {
    type Input = DeleteObjectTaggingInput;
    type Output = DeleteObjectTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_object_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteObjectTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            version_id,
        })
    }
}

impl TryInto<http::Response> for DeleteObjectTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::NO_CONTENT);
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct DeleteObjects;

impl DeleteObjects {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeleteObjectsInput> {
        DeleteObjectsInput::try_from(req)
    }

    pub fn serialize_http(x: DeleteObjectsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeleteObjects {
    fn name(&self) -> &'static str {
        "DeleteObjects"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_objects(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeleteObjects {
    type Input = DeleteObjectsInput;
    type Output = DeleteObjectsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_objects(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeleteObjectsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let bypass_governance_retention: Option<BypassGovernanceRetention> =
            http::parse_opt_header(req, &X_AMZ_BYPASS_GOVERNANCE_RETENTION)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let delete: Delete = http::take_xml_body(req)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let mfa: Option<MFA> = http::parse_opt_header(req, &X_AMZ_MFA)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        Ok(Self {
            bucket,
            bypass_governance_retention,
            checksum_algorithm,
            delete,
            expected_bucket_owner,
            mfa,
            request_payer,
        })
    }
}

impl TryInto<http::Response> for DeleteObjectsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct DeletePublicAccessBlock;

impl DeletePublicAccessBlock {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<DeletePublicAccessBlockInput> {
        DeletePublicAccessBlockInput::try_from(req)
    }

    pub fn serialize_http(x: DeletePublicAccessBlockOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for DeletePublicAccessBlock {
    fn name(&self) -> &'static str {
        "DeletePublicAccessBlock"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.delete_public_access_block(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for DeletePublicAccessBlock {
    type Input = DeletePublicAccessBlockInput;
    type Output = DeletePublicAccessBlockOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.delete_public_access_block(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for DeletePublicAccessBlockInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for DeletePublicAccessBlockOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct GetBucketAccelerateConfiguration;

impl GetBucketAccelerateConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketAccelerateConfigurationInput> {
        GetBucketAccelerateConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketAccelerateConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketAccelerateConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketAccelerateConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_accelerate_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketAccelerateConfiguration {
    type Input = GetBucketAccelerateConfigurationInput;
    type Output = GetBucketAccelerateConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_accelerate_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketAccelerateConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketAccelerateConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketAcl;

impl GetBucketAcl {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketAclInput> {
        GetBucketAclInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketAclOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketAcl {
    fn name(&self) -> &'static str {
        "GetBucketAcl"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_acl(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketAcl {
    type Input = GetBucketAclInput;
    type Output = GetBucketAclOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_acl(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketAclInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketAclOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketAnalyticsConfiguration;

impl GetBucketAnalyticsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketAnalyticsConfigurationInput> {
        GetBucketAnalyticsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketAnalyticsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketAnalyticsConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketAnalyticsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_analytics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketAnalyticsConfiguration {
    type Input = GetBucketAnalyticsConfigurationInput;
    type Output = GetBucketAnalyticsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_analytics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketAnalyticsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: AnalyticsId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for GetBucketAnalyticsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.analytics_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketCors;

impl GetBucketCors {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketCorsInput> {
        GetBucketCorsInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketCorsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketCors {
    fn name(&self) -> &'static str {
        "GetBucketCors"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_cors(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketCors {
    type Input = GetBucketCorsInput;
    type Output = GetBucketCorsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_cors(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketCorsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketCorsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketEncryption;

impl GetBucketEncryption {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketEncryptionInput> {
        GetBucketEncryptionInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketEncryptionOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketEncryption {
    fn name(&self) -> &'static str {
        "GetBucketEncryption"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_encryption(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketEncryption {
    type Input = GetBucketEncryptionInput;
    type Output = GetBucketEncryptionOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_encryption(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketEncryptionInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketEncryptionOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.server_side_encryption_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketIntelligentTieringConfiguration;

impl GetBucketIntelligentTieringConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketIntelligentTieringConfigurationInput> {
        GetBucketIntelligentTieringConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketIntelligentTieringConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketIntelligentTieringConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketIntelligentTieringConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_intelligent_tiering_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketIntelligentTieringConfiguration {
    type Input = GetBucketIntelligentTieringConfigurationInput;
    type Output = GetBucketIntelligentTieringConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_intelligent_tiering_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketIntelligentTieringConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let id: IntelligentTieringId = http::parse_query(req, "id")?;

        Ok(Self { bucket, id })
    }
}

impl TryInto<http::Response> for GetBucketIntelligentTieringConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.intelligent_tiering_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketInventoryConfiguration;

impl GetBucketInventoryConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketInventoryConfigurationInput> {
        GetBucketInventoryConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketInventoryConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketInventoryConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketInventoryConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_inventory_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketInventoryConfiguration {
    type Input = GetBucketInventoryConfigurationInput;
    type Output = GetBucketInventoryConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_inventory_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketInventoryConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: InventoryId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for GetBucketInventoryConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.inventory_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketLifecycleConfiguration;

impl GetBucketLifecycleConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketLifecycleConfigurationInput> {
        GetBucketLifecycleConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketLifecycleConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketLifecycleConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketLifecycleConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_lifecycle_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketLifecycleConfiguration {
    type Input = GetBucketLifecycleConfigurationInput;
    type Output = GetBucketLifecycleConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_lifecycle_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketLifecycleConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketLifecycleConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketLocation;

impl GetBucketLocation {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketLocationInput> {
        GetBucketLocationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketLocationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketLocation {
    fn name(&self) -> &'static str {
        "GetBucketLocation"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_location(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketLocation {
    type Input = GetBucketLocationInput;
    type Output = GetBucketLocationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_location(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketLocationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketLocationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketLogging;

impl GetBucketLogging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketLoggingInput> {
        GetBucketLoggingInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketLoggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketLogging {
    fn name(&self) -> &'static str {
        "GetBucketLogging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_logging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketLogging {
    type Input = GetBucketLoggingInput;
    type Output = GetBucketLoggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_logging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketLoggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketLoggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketMetricsConfiguration;

impl GetBucketMetricsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketMetricsConfigurationInput> {
        GetBucketMetricsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketMetricsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketMetricsConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketMetricsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_metrics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketMetricsConfiguration {
    type Input = GetBucketMetricsConfigurationInput;
    type Output = GetBucketMetricsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_metrics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketMetricsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: MetricsId = http::parse_query(req, "id")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for GetBucketMetricsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.metrics_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketNotificationConfiguration;

impl GetBucketNotificationConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketNotificationConfigurationInput> {
        GetBucketNotificationConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketNotificationConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketNotificationConfiguration {
    fn name(&self) -> &'static str {
        "GetBucketNotificationConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_notification_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketNotificationConfiguration {
    type Input = GetBucketNotificationConfigurationInput;
    type Output = GetBucketNotificationConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_notification_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketNotificationConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketNotificationConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketOwnershipControls;

impl GetBucketOwnershipControls {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketOwnershipControlsInput> {
        GetBucketOwnershipControlsInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketOwnershipControlsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketOwnershipControls {
    fn name(&self) -> &'static str {
        "GetBucketOwnershipControls"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_ownership_controls(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketOwnershipControls {
    type Input = GetBucketOwnershipControlsInput;
    type Output = GetBucketOwnershipControlsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_ownership_controls(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketOwnershipControlsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketOwnershipControlsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.ownership_controls {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketPolicy;

impl GetBucketPolicy {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketPolicyInput> {
        GetBucketPolicyInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketPolicyOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketPolicy {
    fn name(&self) -> &'static str {
        "GetBucketPolicy"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_policy(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketPolicy {
    type Input = GetBucketPolicyInput;
    type Output = GetBucketPolicyOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_policy(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketPolicyInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketPolicyOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(val) = self.policy {
            res.body = http::Body::from(val);
        }
        Ok(res)
    }
}

pub struct GetBucketPolicyStatus;

impl GetBucketPolicyStatus {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketPolicyStatusInput> {
        GetBucketPolicyStatusInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketPolicyStatusOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketPolicyStatus {
    fn name(&self) -> &'static str {
        "GetBucketPolicyStatus"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_policy_status(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketPolicyStatus {
    type Input = GetBucketPolicyStatusInput;
    type Output = GetBucketPolicyStatusOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_policy_status(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketPolicyStatusInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketPolicyStatusOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.policy_status {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketReplication;

impl GetBucketReplication {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketReplicationInput> {
        GetBucketReplicationInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketReplicationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketReplication {
    fn name(&self) -> &'static str {
        "GetBucketReplication"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_replication(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketReplication {
    type Input = GetBucketReplicationInput;
    type Output = GetBucketReplicationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_replication(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketReplicationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketReplicationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.replication_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetBucketRequestPayment;

impl GetBucketRequestPayment {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketRequestPaymentInput> {
        GetBucketRequestPaymentInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketRequestPaymentOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketRequestPayment {
    fn name(&self) -> &'static str {
        "GetBucketRequestPayment"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_request_payment(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketRequestPayment {
    type Input = GetBucketRequestPaymentInput;
    type Output = GetBucketRequestPaymentOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_request_payment(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketRequestPaymentInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketRequestPaymentOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketTagging;

impl GetBucketTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketTaggingInput> {
        GetBucketTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketTagging {
    fn name(&self) -> &'static str {
        "GetBucketTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketTagging {
    type Input = GetBucketTaggingInput;
    type Output = GetBucketTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketVersioning;

impl GetBucketVersioning {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketVersioningInput> {
        GetBucketVersioningInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketVersioningOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketVersioning {
    fn name(&self) -> &'static str {
        "GetBucketVersioning"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_versioning(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketVersioning {
    type Input = GetBucketVersioningInput;
    type Output = GetBucketVersioningOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_versioning(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketVersioningInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketVersioningOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetBucketWebsite;

impl GetBucketWebsite {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetBucketWebsiteInput> {
        GetBucketWebsiteInput::try_from(req)
    }

    pub fn serialize_http(x: GetBucketWebsiteOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetBucketWebsite {
    fn name(&self) -> &'static str {
        "GetBucketWebsite"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_bucket_website(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetBucketWebsite {
    type Input = GetBucketWebsiteInput;
    type Output = GetBucketWebsiteOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_bucket_website(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetBucketWebsiteInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetBucketWebsiteOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct GetObject;

impl GetObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectInput> {
        GetObjectInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObject {
    fn name(&self) -> &'static str {
        "GetObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let overrided_headers = super::get_object::extract_overrided_response_headers(&s3_req)?;
        let result = s3.get_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(overrided_headers);
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObject {
    type Input = GetObjectInput;
    type Output = GetObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let overrided_headers = super::get_object::extract_overrided_response_headers(&req)?;
        let result = s3.get_object(req).await;

        let mut result = result;
        if let Ok(response) = &mut result {
            response.headers.extend(overrided_headers);
        }

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_mode: Option<ChecksumMode> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_MODE)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let if_match: Option<IfMatch> = http::parse_opt_header(req, &IF_MATCH)?;

        let if_modified_since: Option<IfModifiedSince> =
            http::parse_opt_header_timestamp(req, &IF_MODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let if_none_match: Option<IfNoneMatch> = http::parse_opt_header(req, &IF_NONE_MATCH)?;

        let if_unmodified_since: Option<IfUnmodifiedSince> =
            http::parse_opt_header_timestamp(req, &IF_UNMODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let part_number: Option<PartNumber> = http::parse_opt_query(req, "partNumber")?;

        let range: Option<Range> = http::parse_opt_header(req, &RANGE)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let response_cache_control: Option<ResponseCacheControl> = http::parse_opt_query(req, "response-cache-control")?;

        let response_content_disposition: Option<ResponseContentDisposition> =
            http::parse_opt_query(req, "response-content-disposition")?;

        let response_content_encoding: Option<ResponseContentEncoding> = http::parse_opt_query(req, "response-content-encoding")?;

        let response_content_language: Option<ResponseContentLanguage> = http::parse_opt_query(req, "response-content-language")?;

        let response_content_type: Option<ResponseContentType> = http::parse_opt_query(req, "response-content-type")?;

        let response_expires: Option<ResponseExpires> =
            http::parse_opt_query_timestamp(req, "response-expires", TimestampFormat::HttpDate)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            checksum_mode,
            expected_bucket_owner,
            if_match,
            if_modified_since,
            if_none_match,
            if_unmodified_since,
            key,
            part_number,
            range,
            request_payer,
            response_cache_control,
            response_content_disposition,
            response_content_encoding,
            response_content_language,
            response_content_type,
            response_expires,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(val) = self.body {
            http::set_stream_body(&mut res, val);
        }
        http::add_opt_header(&mut res, ACCEPT_RANGES, self.accept_ranges)?;
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, CACHE_CONTROL, self.cache_control)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32, self.checksum_crc32)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32C, self.checksum_crc32c)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA1, self.checksum_sha1)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA256, self.checksum_sha256)?;
        http::add_opt_header(&mut res, CONTENT_DISPOSITION, self.content_disposition)?;
        http::add_opt_header(&mut res, CONTENT_ENCODING, self.content_encoding)?;
        http::add_opt_header(&mut res, CONTENT_LANGUAGE, self.content_language)?;
        http::add_header(&mut res, CONTENT_LENGTH, self.content_length)?;
        http::add_opt_header(&mut res, CONTENT_RANGE, self.content_range)?;
        http::add_opt_header(&mut res, CONTENT_TYPE, self.content_type)?;
        http::add_header(&mut res, X_AMZ_DELETE_MARKER, self.delete_marker)?;
        http::add_opt_header(&mut res, ETAG, self.e_tag)?;
        http::add_opt_header(&mut res, X_AMZ_EXPIRATION, self.expiration)?;
        http::add_opt_header_timestamp(&mut res, EXPIRES, self.expires, TimestampFormat::HttpDate)?;
        http::add_opt_header_timestamp(&mut res, LAST_MODIFIED, self.last_modified, TimestampFormat::HttpDate)?;
        http::add_opt_metadata(&mut res, self.metadata)?;
        http::add_header(&mut res, X_AMZ_MISSING_META, self.missing_meta)?;
        http::add_opt_header(&mut res, X_AMZ_OBJECT_LOCK_LEGAL_HOLD, self.object_lock_legal_hold_status)?;
        http::add_opt_header(&mut res, X_AMZ_OBJECT_LOCK_MODE, self.object_lock_mode)?;
        http::add_opt_header_timestamp(
            &mut res,
            X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE,
            self.object_lock_retain_until_date,
            TimestampFormat::DateTime,
        )?;
        http::add_header(&mut res, X_AMZ_MP_PARTS_COUNT, self.parts_count)?;
        http::add_opt_header(&mut res, X_AMZ_REPLICATION_STATUS, self.replication_status)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_RESTORE, self.restore)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        http::add_opt_header(&mut res, X_AMZ_STORAGE_CLASS, self.storage_class)?;
        http::add_header(&mut res, X_AMZ_TAGGING_COUNT, self.tag_count)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        http::add_opt_header(&mut res, X_AMZ_WEBSITE_REDIRECT_LOCATION, self.website_redirect_location)?;
        Ok(res)
    }
}

pub struct GetObjectAcl;

impl GetObjectAcl {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectAclInput> {
        GetObjectAclInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectAclOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectAcl {
    fn name(&self) -> &'static str {
        "GetObjectAcl"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_acl(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectAcl {
    type Input = GetObjectAclInput;
    type Output = GetObjectAclOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_acl(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectAclInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectAclOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct GetObjectAttributes;

impl GetObjectAttributes {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectAttributesInput> {
        GetObjectAttributesInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectAttributesOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectAttributes {
    fn name(&self) -> &'static str {
        "GetObjectAttributes"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_attributes(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectAttributes {
    type Input = GetObjectAttributesInput;
    type Output = GetObjectAttributesOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_attributes(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectAttributesInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let max_parts: Option<MaxParts> = http::parse_opt_header(req, &X_AMZ_MAX_PARTS)?;

        let object_attributes: ObjectAttributesList = http::parse_list_header(req, &X_AMZ_OBJECT_ATTRIBUTES)?;

        let part_number_marker: Option<PartNumberMarker> = http::parse_opt_header(req, &X_AMZ_PART_NUMBER_MARKER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            max_parts,
            object_attributes,
            part_number_marker,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectAttributesOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_header(&mut res, X_AMZ_DELETE_MARKER, self.delete_marker)?;
        http::add_opt_header_timestamp(&mut res, LAST_MODIFIED, self.last_modified, TimestampFormat::HttpDate)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct GetObjectLegalHold;

impl GetObjectLegalHold {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectLegalHoldInput> {
        GetObjectLegalHoldInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectLegalHoldOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectLegalHold {
    fn name(&self) -> &'static str {
        "GetObjectLegalHold"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_legal_hold(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectLegalHold {
    type Input = GetObjectLegalHoldInput;
    type Output = GetObjectLegalHoldOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_legal_hold(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectLegalHoldInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectLegalHoldOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.legal_hold {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetObjectLockConfiguration;

impl GetObjectLockConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectLockConfigurationInput> {
        GetObjectLockConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectLockConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectLockConfiguration {
    fn name(&self) -> &'static str {
        "GetObjectLockConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_lock_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectLockConfiguration {
    type Input = GetObjectLockConfigurationInput;
    type Output = GetObjectLockConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_lock_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectLockConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetObjectLockConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.object_lock_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetObjectRetention;

impl GetObjectRetention {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectRetentionInput> {
        GetObjectRetentionInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectRetentionOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectRetention {
    fn name(&self) -> &'static str {
        "GetObjectRetention"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_retention(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectRetention {
    type Input = GetObjectRetentionInput;
    type Output = GetObjectRetentionOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_retention(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectRetentionInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectRetentionOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.retention {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct GetObjectTagging;

impl GetObjectTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectTaggingInput> {
        GetObjectTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectTagging {
    fn name(&self) -> &'static str {
        "GetObjectTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectTagging {
    type Input = GetObjectTaggingInput;
    type Output = GetObjectTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for GetObjectTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct GetObjectTorrent;

impl GetObjectTorrent {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetObjectTorrentInput> {
        GetObjectTorrentInput::try_from(req)
    }

    pub fn serialize_http(x: GetObjectTorrentOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetObjectTorrent {
    fn name(&self) -> &'static str {
        "GetObjectTorrent"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_object_torrent(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetObjectTorrent {
    type Input = GetObjectTorrentInput;
    type Output = GetObjectTorrentOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_object_torrent(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetObjectTorrentInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            request_payer,
        })
    }
}

impl TryInto<http::Response> for GetObjectTorrentOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(val) = self.body {
            http::set_stream_body(&mut res, val);
        }
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct GetPublicAccessBlock;

impl GetPublicAccessBlock {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<GetPublicAccessBlockInput> {
        GetPublicAccessBlockInput::try_from(req)
    }

    pub fn serialize_http(x: GetPublicAccessBlockOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for GetPublicAccessBlock {
    fn name(&self) -> &'static str {
        "GetPublicAccessBlock"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.get_public_access_block(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for GetPublicAccessBlock {
    type Input = GetPublicAccessBlockInput;
    type Output = GetPublicAccessBlockOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.get_public_access_block(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for GetPublicAccessBlockInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for GetPublicAccessBlockOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.public_access_block_configuration {
            http::set_xml_body(&mut res, val)?;
        }
        Ok(res)
    }
}

pub struct HeadBucket;

impl HeadBucket {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<HeadBucketInput> {
        HeadBucketInput::try_from(req)
    }

    pub fn serialize_http(x: HeadBucketOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for HeadBucket {
    fn name(&self) -> &'static str {
        "HeadBucket"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.head_bucket(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for HeadBucket {
    type Input = HeadBucketInput;
    type Output = HeadBucketOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.head_bucket(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for HeadBucketInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for HeadBucketOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct HeadObject;

impl HeadObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<HeadObjectInput> {
        HeadObjectInput::try_from(req)
    }

    pub fn serialize_http(x: HeadObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for HeadObject {
    fn name(&self) -> &'static str {
        "HeadObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.head_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for HeadObject {
    type Input = HeadObjectInput;
    type Output = HeadObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.head_object(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for HeadObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_mode: Option<ChecksumMode> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_MODE)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let if_match: Option<IfMatch> = http::parse_opt_header(req, &IF_MATCH)?;

        let if_modified_since: Option<IfModifiedSince> =
            http::parse_opt_header_timestamp(req, &IF_MODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let if_none_match: Option<IfNoneMatch> = http::parse_opt_header(req, &IF_NONE_MATCH)?;

        let if_unmodified_since: Option<IfUnmodifiedSince> =
            http::parse_opt_header_timestamp(req, &IF_UNMODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let part_number: Option<PartNumber> = http::parse_opt_query(req, "partNumber")?;

        let range: Option<Range> = http::parse_opt_header(req, &RANGE)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            checksum_mode,
            expected_bucket_owner,
            if_match,
            if_modified_since,
            if_none_match,
            if_unmodified_since,
            key,
            part_number,
            range,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            version_id,
        })
    }
}

impl TryInto<http::Response> for HeadObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, ACCEPT_RANGES, self.accept_ranges)?;
        http::add_opt_header(&mut res, X_AMZ_ARCHIVE_STATUS, self.archive_status)?;
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, CACHE_CONTROL, self.cache_control)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32, self.checksum_crc32)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32C, self.checksum_crc32c)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA1, self.checksum_sha1)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA256, self.checksum_sha256)?;
        http::add_opt_header(&mut res, CONTENT_DISPOSITION, self.content_disposition)?;
        http::add_opt_header(&mut res, CONTENT_ENCODING, self.content_encoding)?;
        http::add_opt_header(&mut res, CONTENT_LANGUAGE, self.content_language)?;
        http::add_header(&mut res, CONTENT_LENGTH, self.content_length)?;
        http::add_opt_header(&mut res, CONTENT_TYPE, self.content_type)?;
        http::add_header(&mut res, X_AMZ_DELETE_MARKER, self.delete_marker)?;
        http::add_opt_header(&mut res, ETAG, self.e_tag)?;
        http::add_opt_header(&mut res, X_AMZ_EXPIRATION, self.expiration)?;
        http::add_opt_header_timestamp(&mut res, EXPIRES, self.expires, TimestampFormat::HttpDate)?;
        http::add_opt_header_timestamp(&mut res, LAST_MODIFIED, self.last_modified, TimestampFormat::HttpDate)?;
        http::add_opt_metadata(&mut res, self.metadata)?;
        http::add_header(&mut res, X_AMZ_MISSING_META, self.missing_meta)?;
        http::add_opt_header(&mut res, X_AMZ_OBJECT_LOCK_LEGAL_HOLD, self.object_lock_legal_hold_status)?;
        http::add_opt_header(&mut res, X_AMZ_OBJECT_LOCK_MODE, self.object_lock_mode)?;
        http::add_opt_header_timestamp(
            &mut res,
            X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE,
            self.object_lock_retain_until_date,
            TimestampFormat::DateTime,
        )?;
        http::add_header(&mut res, X_AMZ_MP_PARTS_COUNT, self.parts_count)?;
        http::add_opt_header(&mut res, X_AMZ_REPLICATION_STATUS, self.replication_status)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_RESTORE, self.restore)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        http::add_opt_header(&mut res, X_AMZ_STORAGE_CLASS, self.storage_class)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        http::add_opt_header(&mut res, X_AMZ_WEBSITE_REDIRECT_LOCATION, self.website_redirect_location)?;
        Ok(res)
    }
}

pub struct ListBucketAnalyticsConfigurations;

impl ListBucketAnalyticsConfigurations {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListBucketAnalyticsConfigurationsInput> {
        ListBucketAnalyticsConfigurationsInput::try_from(req)
    }

    pub fn serialize_http(x: ListBucketAnalyticsConfigurationsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListBucketAnalyticsConfigurations {
    fn name(&self) -> &'static str {
        "ListBucketAnalyticsConfigurations"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_bucket_analytics_configurations(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListBucketAnalyticsConfigurations {
    type Input = ListBucketAnalyticsConfigurationsInput;
    type Output = ListBucketAnalyticsConfigurationsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_bucket_analytics_configurations(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListBucketAnalyticsConfigurationsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let continuation_token: Option<Token> = http::parse_opt_query(req, "continuation-token")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            continuation_token,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for ListBucketAnalyticsConfigurationsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListBucketIntelligentTieringConfigurations;

impl ListBucketIntelligentTieringConfigurations {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListBucketIntelligentTieringConfigurationsInput> {
        ListBucketIntelligentTieringConfigurationsInput::try_from(req)
    }

    pub fn serialize_http(x: ListBucketIntelligentTieringConfigurationsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListBucketIntelligentTieringConfigurations {
    fn name(&self) -> &'static str {
        "ListBucketIntelligentTieringConfigurations"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_bucket_intelligent_tiering_configurations(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListBucketIntelligentTieringConfigurations {
    type Input = ListBucketIntelligentTieringConfigurationsInput;
    type Output = ListBucketIntelligentTieringConfigurationsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_bucket_intelligent_tiering_configurations(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListBucketIntelligentTieringConfigurationsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let continuation_token: Option<Token> = http::parse_opt_query(req, "continuation-token")?;

        Ok(Self {
            bucket,
            continuation_token,
        })
    }
}

impl TryInto<http::Response> for ListBucketIntelligentTieringConfigurationsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListBucketInventoryConfigurations;

impl ListBucketInventoryConfigurations {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListBucketInventoryConfigurationsInput> {
        ListBucketInventoryConfigurationsInput::try_from(req)
    }

    pub fn serialize_http(x: ListBucketInventoryConfigurationsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListBucketInventoryConfigurations {
    fn name(&self) -> &'static str {
        "ListBucketInventoryConfigurations"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_bucket_inventory_configurations(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListBucketInventoryConfigurations {
    type Input = ListBucketInventoryConfigurationsInput;
    type Output = ListBucketInventoryConfigurationsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_bucket_inventory_configurations(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListBucketInventoryConfigurationsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let continuation_token: Option<Token> = http::parse_opt_query(req, "continuation-token")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            continuation_token,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for ListBucketInventoryConfigurationsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListBucketMetricsConfigurations;

impl ListBucketMetricsConfigurations {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListBucketMetricsConfigurationsInput> {
        ListBucketMetricsConfigurationsInput::try_from(req)
    }

    pub fn serialize_http(x: ListBucketMetricsConfigurationsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListBucketMetricsConfigurations {
    fn name(&self) -> &'static str {
        "ListBucketMetricsConfigurations"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_bucket_metrics_configurations(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListBucketMetricsConfigurations {
    type Input = ListBucketMetricsConfigurationsInput;
    type Output = ListBucketMetricsConfigurationsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_bucket_metrics_configurations(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListBucketMetricsConfigurationsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let continuation_token: Option<Token> = http::parse_opt_query(req, "continuation-token")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            continuation_token,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for ListBucketMetricsConfigurationsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListBuckets;

impl ListBuckets {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListBucketsInput> {
        ListBucketsInput::try_from(req)
    }

    pub fn serialize_http(x: ListBucketsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListBuckets {
    fn name(&self) -> &'static str {
        "ListBuckets"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_buckets(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListBuckets {
    type Input = ListBucketsInput;
    type Output = ListBucketsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_buckets(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListBucketsInput {
    type Error = S3Error;

    fn try_from(_: &mut http::Request) -> S3Result<Self> {
        Ok(Self {})
    }
}

impl TryInto<http::Response> for ListBucketsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListMultipartUploads;

impl ListMultipartUploads {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListMultipartUploadsInput> {
        ListMultipartUploadsInput::try_from(req)
    }

    pub fn serialize_http(x: ListMultipartUploadsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListMultipartUploads {
    fn name(&self) -> &'static str {
        "ListMultipartUploads"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_multipart_uploads(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListMultipartUploads {
    type Input = ListMultipartUploadsInput;
    type Output = ListMultipartUploadsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_multipart_uploads(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListMultipartUploadsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let delimiter: Option<Delimiter> = http::parse_opt_query(req, "delimiter")?;

        let encoding_type: Option<EncodingType> = http::parse_opt_query(req, "encoding-type")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let key_marker: Option<KeyMarker> = http::parse_opt_query(req, "key-marker")?;

        let max_uploads: Option<MaxUploads> = http::parse_opt_query(req, "max-uploads")?;

        let prefix: Option<Prefix> = http::parse_opt_query(req, "prefix")?;

        let upload_id_marker: Option<UploadIdMarker> = http::parse_opt_query(req, "upload-id-marker")?;

        Ok(Self {
            bucket,
            delimiter,
            encoding_type,
            expected_bucket_owner,
            key_marker,
            max_uploads,
            prefix,
            upload_id_marker,
        })
    }
}

impl TryInto<http::Response> for ListMultipartUploadsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListObjectVersions;

impl ListObjectVersions {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListObjectVersionsInput> {
        ListObjectVersionsInput::try_from(req)
    }

    pub fn serialize_http(x: ListObjectVersionsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListObjectVersions {
    fn name(&self) -> &'static str {
        "ListObjectVersions"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_object_versions(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListObjectVersions {
    type Input = ListObjectVersionsInput;
    type Output = ListObjectVersionsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_object_versions(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListObjectVersionsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let delimiter: Option<Delimiter> = http::parse_opt_query(req, "delimiter")?;

        let encoding_type: Option<EncodingType> = http::parse_opt_query(req, "encoding-type")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let key_marker: Option<KeyMarker> = http::parse_opt_query(req, "key-marker")?;

        let max_keys: Option<MaxKeys> = http::parse_opt_query(req, "max-keys")?;

        let prefix: Option<Prefix> = http::parse_opt_query(req, "prefix")?;

        let version_id_marker: Option<VersionIdMarker> = http::parse_opt_query(req, "version-id-marker")?;

        Ok(Self {
            bucket,
            delimiter,
            encoding_type,
            expected_bucket_owner,
            key_marker,
            max_keys,
            prefix,
            version_id_marker,
        })
    }
}

impl TryInto<http::Response> for ListObjectVersionsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListObjects;

impl ListObjects {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListObjectsInput> {
        ListObjectsInput::try_from(req)
    }

    pub fn serialize_http(x: ListObjectsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListObjects {
    fn name(&self) -> &'static str {
        "ListObjects"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_objects(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListObjects {
    type Input = ListObjectsInput;
    type Output = ListObjectsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_objects(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListObjectsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let delimiter: Option<Delimiter> = http::parse_opt_query(req, "delimiter")?;

        let encoding_type: Option<EncodingType> = http::parse_opt_query(req, "encoding-type")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let marker: Option<Marker> = http::parse_opt_query(req, "marker")?;

        let max_keys: Option<MaxKeys> = http::parse_opt_query(req, "max-keys")?;

        let prefix: Option<Prefix> = http::parse_opt_query(req, "prefix")?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        Ok(Self {
            bucket,
            delimiter,
            encoding_type,
            expected_bucket_owner,
            marker,
            max_keys,
            prefix,
            request_payer,
        })
    }
}

impl TryInto<http::Response> for ListObjectsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListObjectsV2;

impl ListObjectsV2 {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListObjectsV2Input> {
        ListObjectsV2Input::try_from(req)
    }

    pub fn serialize_http(x: ListObjectsV2Output) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListObjectsV2 {
    fn name(&self) -> &'static str {
        "ListObjectsV2"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_objects_v2(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListObjectsV2 {
    type Input = ListObjectsV2Input;
    type Output = ListObjectsV2Output;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_objects_v2(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListObjectsV2Input {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let continuation_token: Option<Token> = http::parse_opt_query(req, "continuation-token")?;

        let delimiter: Option<Delimiter> = http::parse_opt_query(req, "delimiter")?;

        let encoding_type: Option<EncodingType> = http::parse_opt_query(req, "encoding-type")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let fetch_owner: Option<FetchOwner> = http::parse_opt_query(req, "fetch-owner")?;

        let max_keys: Option<MaxKeys> = http::parse_opt_query(req, "max-keys")?;

        let prefix: Option<Prefix> = http::parse_opt_query(req, "prefix")?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let start_after: Option<StartAfter> = http::parse_opt_query(req, "start-after")?;

        Ok(Self {
            bucket,
            continuation_token,
            delimiter,
            encoding_type,
            expected_bucket_owner,
            fetch_owner,
            max_keys,
            prefix,
            request_payer,
            start_after,
        })
    }
}

impl TryInto<http::Response> for ListObjectsV2Output {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        Ok(res)
    }
}

pub struct ListParts;

impl ListParts {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<ListPartsInput> {
        ListPartsInput::try_from(req)
    }

    pub fn serialize_http(x: ListPartsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for ListParts {
    fn name(&self) -> &'static str {
        "ListParts"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.list_parts(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for ListParts {
    type Input = ListPartsInput;
    type Output = ListPartsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.list_parts(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for ListPartsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let max_parts: Option<MaxParts> = http::parse_opt_query(req, "max-parts")?;

        let part_number_marker: Option<PartNumberMarker> = http::parse_opt_query(req, "part-number-marker")?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let upload_id: MultipartUploadId = http::parse_query(req, "uploadId")?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            max_parts,
            part_number_marker,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            upload_id,
        })
    }
}

impl TryInto<http::Response> for ListPartsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::set_xml_body(&mut res, &self)?;
        http::add_opt_header_timestamp(&mut res, X_AMZ_ABORT_DATE, self.abort_date, TimestampFormat::HttpDate)?;
        http::add_opt_header(&mut res, X_AMZ_ABORT_RULE_ID, self.abort_rule_id)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct PutBucketAccelerateConfiguration;

impl PutBucketAccelerateConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketAccelerateConfigurationInput> {
        PutBucketAccelerateConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketAccelerateConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketAccelerateConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketAccelerateConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_accelerate_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketAccelerateConfiguration {
    type Input = PutBucketAccelerateConfigurationInput;
    type Output = PutBucketAccelerateConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_accelerate_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketAccelerateConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let accelerate_configuration: AccelerateConfiguration = http::take_xml_body(req)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            accelerate_configuration,
            bucket,
            checksum_algorithm,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for PutBucketAccelerateConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketAcl;

impl PutBucketAcl {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketAclInput> {
        PutBucketAclInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketAclOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketAcl {
    fn name(&self) -> &'static str {
        "PutBucketAcl"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_acl(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketAcl {
    type Input = PutBucketAclInput;
    type Output = PutBucketAclOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_acl(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketAclInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let acl: Option<BucketCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let access_control_policy: Option<AccessControlPolicy> = http::take_opt_xml_body(req)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write: Option<GrantWrite> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        Ok(Self {
            acl,
            access_control_policy,
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write,
            grant_write_acp,
        })
    }
}

impl TryInto<http::Response> for PutBucketAclOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketAnalyticsConfiguration;

impl PutBucketAnalyticsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketAnalyticsConfigurationInput> {
        PutBucketAnalyticsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketAnalyticsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketAnalyticsConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketAnalyticsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_analytics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketAnalyticsConfiguration {
    type Input = PutBucketAnalyticsConfigurationInput;
    type Output = PutBucketAnalyticsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_analytics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketAnalyticsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let analytics_configuration: AnalyticsConfiguration = http::take_xml_body(req)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: AnalyticsId = http::parse_query(req, "id")?;

        Ok(Self {
            analytics_configuration,
            bucket,
            expected_bucket_owner,
            id,
        })
    }
}

impl TryInto<http::Response> for PutBucketAnalyticsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketCors;

impl PutBucketCors {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketCorsInput> {
        PutBucketCorsInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketCorsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketCors {
    fn name(&self) -> &'static str {
        "PutBucketCors"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_cors(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketCors {
    type Input = PutBucketCorsInput;
    type Output = PutBucketCorsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_cors(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketCorsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let cors_configuration: CORSConfiguration = http::take_xml_body(req)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            cors_configuration,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for PutBucketCorsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketEncryption;

impl PutBucketEncryption {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketEncryptionInput> {
        PutBucketEncryptionInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketEncryptionOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketEncryption {
    fn name(&self) -> &'static str {
        "PutBucketEncryption"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_encryption(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketEncryption {
    type Input = PutBucketEncryptionInput;
    type Output = PutBucketEncryptionOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_encryption(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketEncryptionInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let server_side_encryption_configuration: ServerSideEncryptionConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            server_side_encryption_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketEncryptionOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketIntelligentTieringConfiguration;

impl PutBucketIntelligentTieringConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketIntelligentTieringConfigurationInput> {
        PutBucketIntelligentTieringConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketIntelligentTieringConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketIntelligentTieringConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketIntelligentTieringConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_intelligent_tiering_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketIntelligentTieringConfiguration {
    type Input = PutBucketIntelligentTieringConfigurationInput;
    type Output = PutBucketIntelligentTieringConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_intelligent_tiering_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketIntelligentTieringConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let id: IntelligentTieringId = http::parse_query(req, "id")?;

        let intelligent_tiering_configuration: IntelligentTieringConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            id,
            intelligent_tiering_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketIntelligentTieringConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketInventoryConfiguration;

impl PutBucketInventoryConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketInventoryConfigurationInput> {
        PutBucketInventoryConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketInventoryConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketInventoryConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketInventoryConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_inventory_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketInventoryConfiguration {
    type Input = PutBucketInventoryConfigurationInput;
    type Output = PutBucketInventoryConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_inventory_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketInventoryConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: InventoryId = http::parse_query(req, "id")?;

        let inventory_configuration: InventoryConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
            inventory_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketInventoryConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketLifecycleConfiguration;

impl PutBucketLifecycleConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketLifecycleConfigurationInput> {
        PutBucketLifecycleConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketLifecycleConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketLifecycleConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketLifecycleConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_lifecycle_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketLifecycleConfiguration {
    type Input = PutBucketLifecycleConfigurationInput;
    type Output = PutBucketLifecycleConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_lifecycle_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketLifecycleConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let lifecycle_configuration: Option<BucketLifecycleConfiguration> = http::take_opt_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            expected_bucket_owner,
            lifecycle_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketLifecycleConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketLogging;

impl PutBucketLogging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketLoggingInput> {
        PutBucketLoggingInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketLoggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketLogging {
    fn name(&self) -> &'static str {
        "PutBucketLogging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_logging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketLogging {
    type Input = PutBucketLoggingInput;
    type Output = PutBucketLoggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_logging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketLoggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let bucket_logging_status: BucketLoggingStatus = http::take_xml_body(req)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        Ok(Self {
            bucket,
            bucket_logging_status,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
        })
    }
}

impl TryInto<http::Response> for PutBucketLoggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketMetricsConfiguration;

impl PutBucketMetricsConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketMetricsConfigurationInput> {
        PutBucketMetricsConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketMetricsConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketMetricsConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketMetricsConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_metrics_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketMetricsConfiguration {
    type Input = PutBucketMetricsConfigurationInput;
    type Output = PutBucketMetricsConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_metrics_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketMetricsConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let id: MetricsId = http::parse_query(req, "id")?;

        let metrics_configuration: MetricsConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            id,
            metrics_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketMetricsConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketNotificationConfiguration;

impl PutBucketNotificationConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketNotificationConfigurationInput> {
        PutBucketNotificationConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketNotificationConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketNotificationConfiguration {
    fn name(&self) -> &'static str {
        "PutBucketNotificationConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_notification_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketNotificationConfiguration {
    type Input = PutBucketNotificationConfigurationInput;
    type Output = PutBucketNotificationConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_notification_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketNotificationConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let notification_configuration: NotificationConfiguration = http::take_xml_body(req)?;

        let skip_destination_validation: Option<SkipValidation> =
            http::parse_opt_header(req, &X_AMZ_SKIP_DESTINATION_VALIDATION)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            notification_configuration,
            skip_destination_validation,
        })
    }
}

impl TryInto<http::Response> for PutBucketNotificationConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketOwnershipControls;

impl PutBucketOwnershipControls {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketOwnershipControlsInput> {
        PutBucketOwnershipControlsInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketOwnershipControlsOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketOwnershipControls {
    fn name(&self) -> &'static str {
        "PutBucketOwnershipControls"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_ownership_controls(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketOwnershipControls {
    type Input = PutBucketOwnershipControlsInput;
    type Output = PutBucketOwnershipControlsOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_ownership_controls(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketOwnershipControlsInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let ownership_controls: OwnershipControls = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            content_md5,
            expected_bucket_owner,
            ownership_controls,
        })
    }
}

impl TryInto<http::Response> for PutBucketOwnershipControlsOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketPolicy;

impl PutBucketPolicy {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketPolicyInput> {
        PutBucketPolicyInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketPolicyOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketPolicy {
    fn name(&self) -> &'static str {
        "PutBucketPolicy"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_policy(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketPolicy {
    type Input = PutBucketPolicyInput;
    type Output = PutBucketPolicyOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_policy(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketPolicyInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let confirm_remove_self_bucket_access: Option<ConfirmRemoveSelfBucketAccess> =
            http::parse_opt_header(req, &X_AMZ_CONFIRM_REMOVE_SELF_BUCKET_ACCESS)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let policy: Policy = http::take_string_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            confirm_remove_self_bucket_access,
            content_md5,
            expected_bucket_owner,
            policy,
        })
    }
}

impl TryInto<http::Response> for PutBucketPolicyOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::NO_CONTENT))
    }
}

pub struct PutBucketReplication;

impl PutBucketReplication {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketReplicationInput> {
        PutBucketReplicationInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketReplicationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketReplication {
    fn name(&self) -> &'static str {
        "PutBucketReplication"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_replication(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketReplication {
    type Input = PutBucketReplicationInput;
    type Output = PutBucketReplicationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_replication(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketReplicationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let replication_configuration: ReplicationConfiguration = http::take_xml_body(req)?;

        let token: Option<ObjectLockToken> = http::parse_opt_header(req, &X_AMZ_BUCKET_OBJECT_LOCK_TOKEN)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            replication_configuration,
            token,
        })
    }
}

impl TryInto<http::Response> for PutBucketReplicationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketRequestPayment;

impl PutBucketRequestPayment {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketRequestPaymentInput> {
        PutBucketRequestPaymentInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketRequestPaymentOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketRequestPayment {
    fn name(&self) -> &'static str {
        "PutBucketRequestPayment"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_request_payment(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketRequestPayment {
    type Input = PutBucketRequestPaymentInput;
    type Output = PutBucketRequestPaymentOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_request_payment(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketRequestPaymentInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payment_configuration: RequestPaymentConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            request_payment_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketRequestPaymentOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketTagging;

impl PutBucketTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketTaggingInput> {
        PutBucketTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketTagging {
    fn name(&self) -> &'static str {
        "PutBucketTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketTagging {
    type Input = PutBucketTaggingInput;
    type Output = PutBucketTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let tagging: Tagging = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            tagging,
        })
    }
}

impl TryInto<http::Response> for PutBucketTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketVersioning;

impl PutBucketVersioning {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketVersioningInput> {
        PutBucketVersioningInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketVersioningOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketVersioning {
    fn name(&self) -> &'static str {
        "PutBucketVersioning"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_versioning(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketVersioning {
    type Input = PutBucketVersioningInput;
    type Output = PutBucketVersioningOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_versioning(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketVersioningInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let mfa: Option<MFA> = http::parse_opt_header(req, &X_AMZ_MFA)?;

        let versioning_configuration: VersioningConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            mfa,
            versioning_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketVersioningOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutBucketWebsite;

impl PutBucketWebsite {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutBucketWebsiteInput> {
        PutBucketWebsiteInput::try_from(req)
    }

    pub fn serialize_http(x: PutBucketWebsiteOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutBucketWebsite {
    fn name(&self) -> &'static str {
        "PutBucketWebsite"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_bucket_website(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutBucketWebsite {
    type Input = PutBucketWebsiteInput;
    type Output = PutBucketWebsiteOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_bucket_website(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutBucketWebsiteInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let website_configuration: WebsiteConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            website_configuration,
        })
    }
}

impl TryInto<http::Response> for PutBucketWebsiteOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct PutObject;

impl PutObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectInput> {
        PutObjectInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }

    pub fn deserialize_http_multipart(req: &mut http::Request, m: http::Multipart) -> S3Result<PutObjectInput> {
        Ok(PutObjectInput::try_from((req, m))?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObject {
    fn name(&self) -> &'static str {
        "PutObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObject {
    type Input = PutObjectInput;
    type Output = PutObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        if let Some(m) = req.s3ext.multipart.take() {
            return Self::try_from((req, m));
        }

        let (bucket, key) = http::unwrap_object(req);

        let acl: Option<ObjectCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let body: Option<StreamingBlob> = Some(http::take_stream_body(req));

        let bucket_key_enabled: Option<BucketKeyEnabled> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED)?;

        let cache_control: Option<CacheControl> = http::parse_opt_header(req, &CACHE_CONTROL)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let checksum_crc32: Option<ChecksumCRC32> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32)?;

        let checksum_crc32c: Option<ChecksumCRC32C> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32C)?;

        let checksum_sha1: Option<ChecksumSHA1> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA1)?;

        let checksum_sha256: Option<ChecksumSHA256> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA256)?;

        let content_disposition: Option<ContentDisposition> = http::parse_opt_header(req, &CONTENT_DISPOSITION)?;

        let content_encoding: Option<ContentEncoding> = http::parse_opt_header(req, &CONTENT_ENCODING)?;

        let content_language: Option<ContentLanguage> = http::parse_opt_header(req, &CONTENT_LANGUAGE)?;

        let content_length: Option<ContentLength> = http::parse_opt_header(req, &CONTENT_LENGTH)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let content_type: Option<ContentType> = http::parse_opt_header(req, &CONTENT_TYPE)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let expires: Option<Expires> = http::parse_opt_header_timestamp(req, &EXPIRES, TimestampFormat::HttpDate)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        let metadata: Option<Metadata> = http::parse_opt_metadata(req)?;

        let object_lock_legal_hold_status: Option<ObjectLockLegalHoldStatus> =
            http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_LEGAL_HOLD)?;

        let object_lock_mode: Option<ObjectLockMode> = http::parse_opt_header(req, &X_AMZ_OBJECT_LOCK_MODE)?;

        let object_lock_retain_until_date: Option<ObjectLockRetainUntilDate> =
            http::parse_opt_header_timestamp(req, &X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE, TimestampFormat::DateTime)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let ssekms_encryption_context: Option<SSEKMSEncryptionContext> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT)?;

        let ssekms_key_id: Option<SSEKMSKeyId> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID)?;

        let server_side_encryption: Option<ServerSideEncryption> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION)?;

        let storage_class: Option<StorageClass> = http::parse_opt_header(req, &X_AMZ_STORAGE_CLASS)?;

        let tagging: Option<TaggingHeader> = http::parse_opt_header(req, &X_AMZ_TAGGING)?;

        let website_redirect_location: Option<WebsiteRedirectLocation> =
            http::parse_opt_header(req, &X_AMZ_WEBSITE_REDIRECT_LOCATION)?;

        Ok(Self {
            acl,
            body,
            bucket,
            bucket_key_enabled,
            cache_control,
            checksum_algorithm,
            checksum_crc32,
            checksum_crc32c,
            checksum_sha1,
            checksum_sha256,
            content_disposition,
            content_encoding,
            content_language,
            content_length,
            content_md5,
            content_type,
            expected_bucket_owner,
            expires,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write_acp,
            key,
            metadata,
            object_lock_legal_hold_status,
            object_lock_mode,
            object_lock_retain_until_date,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            ssekms_encryption_context,
            ssekms_key_id,
            server_side_encryption,
            storage_class,
            tagging,
            website_redirect_location,
        })
    }
}

impl TryFrom<(&mut http::Request, http::Multipart)> for PutObjectInput {
    type Error = S3Error;

    fn try_from((req, m): (&mut http::Request, http::Multipart)) -> S3Result<PutObjectInput> {
        let bucket = http::unwrap_bucket(req);
        let key = http::parse_field_value(&m, "key")?.ok_or_else(|| invalid_request!("missing key"))?;

        let vec_stream = req.s3ext.vec_stream.take().expect("missing vec stream");

        let content_length = i64::try_from(vec_stream.exact_remaining_length())
            .map_err(|e| s3_error!(e, InvalidArgument, "content-length overflow"))?;
        let content_length = (content_length != 0).then_some(content_length);

        let body: Option<StreamingBlob> = Some(StreamingBlob::new(vec_stream));

        let acl: Option<ObjectCannedACL> = http::parse_field_value(&m, "x-amz-acl")?;

        let bucket_key_enabled: Option<BucketKeyEnabled> =
            http::parse_field_value(&m, "x-amz-server-side-encryption-bucket-key-enabled")?;

        let cache_control: Option<CacheControl> = http::parse_field_value(&m, "cache-control")?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_field_value(&m, "x-amz-sdk-checksum-algorithm")?;

        let checksum_crc32: Option<ChecksumCRC32> = http::parse_field_value(&m, "x-amz-checksum-crc32")?;

        let checksum_crc32c: Option<ChecksumCRC32C> = http::parse_field_value(&m, "x-amz-checksum-crc32c")?;

        let checksum_sha1: Option<ChecksumSHA1> = http::parse_field_value(&m, "x-amz-checksum-sha1")?;

        let checksum_sha256: Option<ChecksumSHA256> = http::parse_field_value(&m, "x-amz-checksum-sha256")?;

        let content_disposition: Option<ContentDisposition> = http::parse_field_value(&m, "content-disposition")?;

        let content_encoding: Option<ContentEncoding> = http::parse_field_value(&m, "content-encoding")?;

        let content_language: Option<ContentLanguage> = http::parse_field_value(&m, "content-language")?;

        let content_md5: Option<ContentMD5> = http::parse_field_value(&m, "content-md5")?;

        let content_type: Option<ContentType> = http::parse_field_value(&m, "content-type")?;

        let expected_bucket_owner: Option<AccountId> = http::parse_field_value(&m, "x-amz-expected-bucket-owner")?;

        let expires: Option<Expires> = http::parse_field_value_timestamp(&m, "expires", TimestampFormat::HttpDate)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_field_value(&m, "x-amz-grant-full-control")?;

        let grant_read: Option<GrantRead> = http::parse_field_value(&m, "x-amz-grant-read")?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_field_value(&m, "x-amz-grant-read-acp")?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_field_value(&m, "x-amz-grant-write-acp")?;

        let metadata: Option<Metadata> = {
            let mut metadata = Metadata::default();
            for (name, value) in m.fields() {
                if let Some(key) = name.strip_prefix("x-amz-meta-") {
                    if key.is_empty() {
                        continue;
                    }
                    metadata.insert(key.to_owned(), value.clone());
                }
            }
            if metadata.is_empty() {
                None
            } else {
                Some(metadata)
            }
        };

        let object_lock_legal_hold_status: Option<ObjectLockLegalHoldStatus> =
            http::parse_field_value(&m, "x-amz-object-lock-legal-hold")?;

        let object_lock_mode: Option<ObjectLockMode> = http::parse_field_value(&m, "x-amz-object-lock-mode")?;

        let object_lock_retain_until_date: Option<ObjectLockRetainUntilDate> =
            http::parse_field_value_timestamp(&m, "x-amz-object-lock-retain-until-date", TimestampFormat::DateTime)?;

        let request_payer: Option<RequestPayer> = http::parse_field_value(&m, "x-amz-request-payer")?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_field_value(&m, "x-amz-server-side-encryption-customer-algorithm")?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_field_value(&m, "x-amz-server-side-encryption-customer-key")?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_field_value(&m, "x-amz-server-side-encryption-customer-key-md5")?;

        let ssekms_encryption_context: Option<SSEKMSEncryptionContext> =
            http::parse_field_value(&m, "x-amz-server-side-encryption-context")?;

        let ssekms_key_id: Option<SSEKMSKeyId> = http::parse_field_value(&m, "x-amz-server-side-encryption-aws-kms-key-id")?;

        let server_side_encryption: Option<ServerSideEncryption> = http::parse_field_value(&m, "x-amz-server-side-encryption")?;

        let storage_class: Option<StorageClass> = http::parse_field_value(&m, "x-amz-storage-class")?;

        let tagging: Option<TaggingHeader> = http::parse_field_value(&m, "x-amz-tagging")?;

        let website_redirect_location: Option<WebsiteRedirectLocation> =
            http::parse_field_value(&m, "x-amz-website-redirect-location")?;

        Ok(Self {
            acl,
            body,
            bucket,
            bucket_key_enabled,
            cache_control,
            checksum_algorithm,
            checksum_crc32,
            checksum_crc32c,
            checksum_sha1,
            checksum_sha256,
            content_disposition,
            content_encoding,
            content_language,
            content_length,
            content_md5,
            content_type,
            expected_bucket_owner,
            expires,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write_acp,
            key,
            metadata,
            object_lock_legal_hold_status,
            object_lock_mode,
            object_lock_retain_until_date,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            ssekms_encryption_context,
            ssekms_key_id,
            server_side_encryption,
            storage_class,
            tagging,
            website_redirect_location,
        })
    }
}

impl TryInto<http::Response> for PutObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32, self.checksum_crc32)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32C, self.checksum_crc32c)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA1, self.checksum_sha1)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA256, self.checksum_sha256)?;
        http::add_opt_header(&mut res, ETAG, self.e_tag)?;
        http::add_opt_header(&mut res, X_AMZ_EXPIRATION, self.expiration)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT, self.ssekms_encryption_context)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct PutObjectAcl;

impl PutObjectAcl {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectAclInput> {
        PutObjectAclInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectAclOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObjectAcl {
    fn name(&self) -> &'static str {
        "PutObjectAcl"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object_acl(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObjectAcl {
    type Input = PutObjectAclInput;
    type Output = PutObjectAclOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object_acl(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectAclInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let acl: Option<ObjectCannedACL> = http::parse_opt_header(req, &X_AMZ_ACL)?;

        let access_control_policy: Option<AccessControlPolicy> = http::take_opt_xml_body(req)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let grant_full_control: Option<GrantFullControl> = http::parse_opt_header(req, &X_AMZ_GRANT_FULL_CONTROL)?;

        let grant_read: Option<GrantRead> = http::parse_opt_header(req, &X_AMZ_GRANT_READ)?;

        let grant_read_acp: Option<GrantReadACP> = http::parse_opt_header(req, &X_AMZ_GRANT_READ_ACP)?;

        let grant_write: Option<GrantWrite> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE)?;

        let grant_write_acp: Option<GrantWriteACP> = http::parse_opt_header(req, &X_AMZ_GRANT_WRITE_ACP)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            acl,
            access_control_policy,
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            grant_full_control,
            grant_read,
            grant_read_acp,
            grant_write,
            grant_write_acp,
            key,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for PutObjectAclOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct PutObjectLegalHold;

impl PutObjectLegalHold {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectLegalHoldInput> {
        PutObjectLegalHoldInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectLegalHoldOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObjectLegalHold {
    fn name(&self) -> &'static str {
        "PutObjectLegalHold"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object_legal_hold(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObjectLegalHold {
    type Input = PutObjectLegalHoldInput;
    type Output = PutObjectLegalHoldOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object_legal_hold(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectLegalHoldInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let legal_hold: Option<ObjectLockLegalHold> = http::take_opt_xml_body(req)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            key,
            legal_hold,
            request_payer,
            version_id,
        })
    }
}

impl TryInto<http::Response> for PutObjectLegalHoldOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct PutObjectLockConfiguration;

impl PutObjectLockConfiguration {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectLockConfigurationInput> {
        PutObjectLockConfigurationInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectLockConfigurationOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObjectLockConfiguration {
    fn name(&self) -> &'static str {
        "PutObjectLockConfiguration"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object_lock_configuration(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObjectLockConfiguration {
    type Input = PutObjectLockConfigurationInput;
    type Output = PutObjectLockConfigurationOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object_lock_configuration(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectLockConfigurationInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let object_lock_configuration: Option<ObjectLockConfiguration> = http::take_opt_xml_body(req)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let token: Option<ObjectLockToken> = http::parse_opt_header(req, &X_AMZ_BUCKET_OBJECT_LOCK_TOKEN)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            object_lock_configuration,
            request_payer,
            token,
        })
    }
}

impl TryInto<http::Response> for PutObjectLockConfigurationOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct PutObjectRetention;

impl PutObjectRetention {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectRetentionInput> {
        PutObjectRetentionInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectRetentionOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObjectRetention {
    fn name(&self) -> &'static str {
        "PutObjectRetention"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object_retention(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObjectRetention {
    type Input = PutObjectRetentionInput;
    type Output = PutObjectRetentionOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object_retention(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectRetentionInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let bypass_governance_retention: Option<BypassGovernanceRetention> =
            http::parse_opt_header(req, &X_AMZ_BYPASS_GOVERNANCE_RETENTION)?;

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let retention: Option<ObjectLockRetention> = http::take_opt_xml_body(req)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            bypass_governance_retention,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            key,
            request_payer,
            retention,
            version_id,
        })
    }
}

impl TryInto<http::Response> for PutObjectRetentionOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        Ok(res)
    }
}

pub struct PutObjectTagging;

impl PutObjectTagging {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutObjectTaggingInput> {
        PutObjectTaggingInput::try_from(req)
    }

    pub fn serialize_http(x: PutObjectTaggingOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutObjectTagging {
    fn name(&self) -> &'static str {
        "PutObjectTagging"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_object_tagging(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutObjectTagging {
    type Input = PutObjectTaggingInput;
    type Output = PutObjectTaggingOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_object_tagging(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutObjectTaggingInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let tagging: Tagging = http::take_xml_body(req)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            key,
            request_payer,
            tagging,
            version_id,
        })
    }
}

impl TryInto<http::Response> for PutObjectTaggingOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_VERSION_ID, self.version_id)?;
        Ok(res)
    }
}

pub struct PutPublicAccessBlock;

impl PutPublicAccessBlock {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<PutPublicAccessBlockInput> {
        PutPublicAccessBlockInput::try_from(req)
    }

    pub fn serialize_http(x: PutPublicAccessBlockOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for PutPublicAccessBlock {
    fn name(&self) -> &'static str {
        "PutPublicAccessBlock"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.put_public_access_block(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for PutPublicAccessBlock {
    type Input = PutPublicAccessBlockInput;
    type Output = PutPublicAccessBlockOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.put_public_access_block(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for PutPublicAccessBlockInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let bucket = http::unwrap_bucket(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let public_access_block_configuration: PublicAccessBlockConfiguration = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            content_md5,
            expected_bucket_owner,
            public_access_block_configuration,
        })
    }
}

impl TryInto<http::Response> for PutPublicAccessBlockOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

pub struct RestoreObject;

impl RestoreObject {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<RestoreObjectInput> {
        RestoreObjectInput::try_from(req)
    }

    pub fn serialize_http(x: RestoreObjectOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for RestoreObject {
    fn name(&self) -> &'static str {
        "RestoreObject"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.restore_object(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for RestoreObject {
    type Input = RestoreObjectInput;
    type Output = RestoreObjectOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.restore_object(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for RestoreObjectInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let restore_request: Option<RestoreRequest> = http::take_opt_xml_body(req)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_query(req, "versionId")?;

        Ok(Self {
            bucket,
            checksum_algorithm,
            expected_bucket_owner,
            key,
            request_payer,
            restore_request,
            version_id,
        })
    }
}

impl TryInto<http::Response> for RestoreObjectOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_RESTORE_OUTPUT_PATH, self.restore_output_path)?;
        Ok(res)
    }
}

pub struct SelectObjectContent;

impl SelectObjectContent {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<SelectObjectContentInput> {
        SelectObjectContentInput::try_from(req)
    }

    pub fn serialize_http(x: SelectObjectContentOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for SelectObjectContent {
    fn name(&self) -> &'static str {
        "SelectObjectContent"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.select_object_content(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for SelectObjectContent {
    type Input = SelectObjectContentInput;
    type Output = SelectObjectContentOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.select_object_content(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for SelectObjectContentInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let request: SelectObjectContentRequest = http::take_xml_body(req)?;

        Ok(Self {
            bucket,
            expected_bucket_owner,
            key,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            request,
        })
    }
}

impl TryInto<http::Response> for SelectObjectContentOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(val) = self.payload {
            http::set_event_stream_body(&mut res, val);
        }
        Ok(res)
    }
}

pub struct UploadPart;

impl UploadPart {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<UploadPartInput> {
        UploadPartInput::try_from(req)
    }

    pub fn serialize_http(x: UploadPartOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for UploadPart {
    fn name(&self) -> &'static str {
        "UploadPart"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.upload_part(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for UploadPart {
    type Input = UploadPartInput;
    type Output = UploadPartOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.upload_part(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for UploadPartInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let body: Option<StreamingBlob> = Some(http::take_stream_body(req));

        let checksum_algorithm: Option<ChecksumAlgorithm> = http::parse_opt_header(req, &X_AMZ_SDK_CHECKSUM_ALGORITHM)?;

        let checksum_crc32: Option<ChecksumCRC32> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32)?;

        let checksum_crc32c: Option<ChecksumCRC32C> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_CRC32C)?;

        let checksum_sha1: Option<ChecksumSHA1> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA1)?;

        let checksum_sha256: Option<ChecksumSHA256> = http::parse_opt_header(req, &X_AMZ_CHECKSUM_SHA256)?;

        let content_length: Option<ContentLength> = http::parse_opt_header(req, &CONTENT_LENGTH)?;

        let content_md5: Option<ContentMD5> = http::parse_opt_header(req, &CONTENT_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let part_number: PartNumber = http::parse_opt_query(req, "partNumber")?.unwrap_or(0);

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let upload_id: MultipartUploadId = http::parse_query(req, "uploadId")?;

        Ok(Self {
            body,
            bucket,
            checksum_algorithm,
            checksum_crc32,
            checksum_crc32c,
            checksum_sha1,
            checksum_sha256,
            content_length,
            content_md5,
            expected_bucket_owner,
            key,
            part_number,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            upload_id,
        })
    }
}

impl TryInto<http::Response> for UploadPartOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32, self.checksum_crc32)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_CRC32C, self.checksum_crc32c)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA1, self.checksum_sha1)?;
        http::add_opt_header(&mut res, X_AMZ_CHECKSUM_SHA256, self.checksum_sha256)?;
        http::add_opt_header(&mut res, ETAG, self.e_tag)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        Ok(res)
    }
}

pub struct UploadPartCopy;

impl UploadPartCopy {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<UploadPartCopyInput> {
        UploadPartCopyInput::try_from(req)
    }

    pub fn serialize_http(x: UploadPartCopyOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for UploadPartCopy {
    fn name(&self) -> &'static str {
        "UploadPartCopy"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.upload_part_copy(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for UploadPartCopy {
    type Input = UploadPartCopyInput;
    type Output = UploadPartCopyOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.upload_part_copy(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for UploadPartCopyInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let (bucket, key) = http::unwrap_object(req);

        let copy_source: CopySource = http::parse_header(req, &X_AMZ_COPY_SOURCE)?;

        let copy_source_if_match: Option<CopySourceIfMatch> = http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_IF_MATCH)?;

        let copy_source_if_modified_since: Option<CopySourceIfModifiedSince> =
            http::parse_opt_header_timestamp(req, &X_AMZ_COPY_SOURCE_IF_MODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let copy_source_if_none_match: Option<CopySourceIfNoneMatch> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_IF_NONE_MATCH)?;

        let copy_source_if_unmodified_since: Option<CopySourceIfUnmodifiedSince> =
            http::parse_opt_header_timestamp(req, &X_AMZ_COPY_SOURCE_IF_UNMODIFIED_SINCE, TimestampFormat::HttpDate)?;

        let copy_source_range: Option<CopySourceRange> = http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_RANGE)?;

        let copy_source_sse_customer_algorithm: Option<CopySourceSSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let copy_source_sse_customer_key: Option<CopySourceSSECustomerKey> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let copy_source_sse_customer_key_md5: Option<CopySourceSSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let expected_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_EXPECTED_BUCKET_OWNER)?;

        let expected_source_bucket_owner: Option<AccountId> = http::parse_opt_header(req, &X_AMZ_SOURCE_EXPECTED_BUCKET_OWNER)?;

        let part_number: PartNumber = http::parse_opt_query(req, "partNumber")?.unwrap_or(0);

        let request_payer: Option<RequestPayer> = http::parse_opt_header(req, &X_AMZ_REQUEST_PAYER)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key: Option<SSECustomerKey> = http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let upload_id: MultipartUploadId = http::parse_query(req, "uploadId")?;

        Ok(Self {
            bucket,
            copy_source,
            copy_source_if_match,
            copy_source_if_modified_since,
            copy_source_if_none_match,
            copy_source_if_unmodified_since,
            copy_source_range,
            copy_source_sse_customer_algorithm,
            copy_source_sse_customer_key,
            copy_source_sse_customer_key_md5,
            expected_bucket_owner,
            expected_source_bucket_owner,
            key,
            part_number,
            request_payer,
            sse_customer_algorithm,
            sse_customer_key,
            sse_customer_key_md5,
            upload_id,
        })
    }
}

impl TryInto<http::Response> for UploadPartCopyOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        let mut res = http::Response::with_status(http::StatusCode::OK);
        if let Some(ref val) = self.copy_part_result {
            http::set_xml_body(&mut res, val)?;
        }
        http::add_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED, self.bucket_key_enabled)?;
        http::add_opt_header(&mut res, X_AMZ_COPY_SOURCE_VERSION_ID, self.copy_source_version_id)?;
        http::add_opt_header(&mut res, X_AMZ_REQUEST_CHARGED, self.request_charged)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, self.sse_customer_algorithm)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, self.sse_customer_key_md5)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, self.ssekms_key_id)?;
        http::add_opt_header(&mut res, X_AMZ_SERVER_SIDE_ENCRYPTION, self.server_side_encryption)?;
        Ok(res)
    }
}

pub struct WriteGetObjectResponse;

impl WriteGetObjectResponse {
    pub fn deserialize_http(req: &mut http::Request) -> S3Result<WriteGetObjectResponseInput> {
        WriteGetObjectResponseInput::try_from(req)
    }

    pub fn serialize_http(x: WriteGetObjectResponseOutput) -> S3Result<http::Response> {
        Ok(x.try_into()?)
    }
}

#[async_trait::async_trait]
impl super::Operation for WriteGetObjectResponse {
    fn name(&self) -> &'static str {
        "WriteGetObjectResponse"
    }

    async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        let input = Self::deserialize_http(req)?;
        let s3_req = super::build_s3_request(input, req);
        let result = s3.write_get_object_response(s3_req).await;
        let s3_resp = match result {
            Ok(val) => val,
            Err(err) => return super::serialize_error(err),
        };
        let mut resp = Self::serialize_http(s3_resp.output)?;
        resp.headers.extend(s3_resp.headers);
        resp.extensions.extend(s3_resp.extensions);
        Ok(resp)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        {
            self
        }
    }
}

#[async_trait::async_trait]
impl super::TypedOperation for WriteGetObjectResponse {
    type Input = WriteGetObjectResponseInput;
    type Output = WriteGetObjectResponseOutput;

    async fn call(&self, s3: &Arc<dyn S3>, req: S3Request<Self::Input>) -> S3Result<S3Response<Self::Output>> {
        let result = s3.write_get_object_response(req).await;

        result
    }
}

impl TryFrom<&mut http::Request> for WriteGetObjectResponseInput {
    type Error = S3Error;

    fn try_from(req: &mut http::Request) -> S3Result<Self> {
        let accept_ranges: Option<AcceptRanges> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_ACCEPT_RANGES)?;

        let body: Option<StreamingBlob> = Some(http::take_stream_body(req));

        let bucket_key_enabled: Option<BucketKeyEnabled> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_SERVER_SIDE_ENCRYPTION_BUCKET_KEY_ENABLED)?;

        let cache_control: Option<CacheControl> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CACHE_CONTROL)?;

        let checksum_crc32: Option<ChecksumCRC32> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_CHECKSUM_CRC32)?;

        let checksum_crc32c: Option<ChecksumCRC32C> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_CHECKSUM_CRC32C)?;

        let checksum_sha1: Option<ChecksumSHA1> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_CHECKSUM_SHA1)?;

        let checksum_sha256: Option<ChecksumSHA256> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_CHECKSUM_SHA256)?;

        let content_disposition: Option<ContentDisposition> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CONTENT_DISPOSITION)?;

        let content_encoding: Option<ContentEncoding> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CONTENT_ENCODING)?;

        let content_language: Option<ContentLanguage> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CONTENT_LANGUAGE)?;

        let content_length: Option<ContentLength> = http::parse_opt_header(req, &CONTENT_LENGTH)?;

        let content_range: Option<ContentRange> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CONTENT_RANGE)?;

        let content_type: Option<ContentType> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_CONTENT_TYPE)?;

        let delete_marker: Option<DeleteMarker> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_DELETE_MARKER)?;

        let e_tag: Option<ETag> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_E_TAG)?;

        let error_code: Option<ErrorCode> = http::parse_opt_header(req, &X_AMZ_FWD_ERROR_CODE)?;

        let error_message: Option<ErrorMessage> = http::parse_opt_header(req, &X_AMZ_FWD_ERROR_MESSAGE)?;

        let expiration: Option<Expiration> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_EXPIRATION)?;

        let expires: Option<Expires> =
            http::parse_opt_header_timestamp(req, &X_AMZ_FWD_HEADER_EXPIRES, TimestampFormat::HttpDate)?;

        let last_modified: Option<LastModified> =
            http::parse_opt_header_timestamp(req, &X_AMZ_FWD_HEADER_LAST_MODIFIED, TimestampFormat::HttpDate)?;

        let metadata: Option<Metadata> = http::parse_opt_metadata(req)?;

        let missing_meta: Option<MissingMeta> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_MISSING_META)?;

        let object_lock_legal_hold_status: Option<ObjectLockLegalHoldStatus> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_OBJECT_LOCK_LEGAL_HOLD)?;

        let object_lock_mode: Option<ObjectLockMode> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_OBJECT_LOCK_MODE)?;

        let object_lock_retain_until_date: Option<ObjectLockRetainUntilDate> = http::parse_opt_header_timestamp(
            req,
            &X_AMZ_FWD_HEADER_X_AMZ_OBJECT_LOCK_RETAIN_UNTIL_DATE,
            TimestampFormat::DateTime,
        )?;

        let parts_count: Option<PartsCount> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_MP_PARTS_COUNT)?;

        let replication_status: Option<ReplicationStatus> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_REPLICATION_STATUS)?;

        let request_charged: Option<RequestCharged> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_REQUEST_CHARGED)?;

        let request_route: RequestRoute = http::parse_header(req, &X_AMZ_REQUEST_ROUTE)?;

        let request_token: RequestToken = http::parse_header(req, &X_AMZ_REQUEST_TOKEN)?;

        let restore: Option<Restore> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_RESTORE)?;

        let sse_customer_algorithm: Option<SSECustomerAlgorithm> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM)?;

        let sse_customer_key_md5: Option<SSECustomerKeyMD5> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5)?;

        let ssekms_key_id: Option<SSEKMSKeyId> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID)?;

        let server_side_encryption: Option<ServerSideEncryption> =
            http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_SERVER_SIDE_ENCRYPTION)?;

        let status_code: Option<GetObjectResponseStatusCode> = http::parse_opt_header(req, &X_AMZ_FWD_STATUS)?;

        let storage_class: Option<StorageClass> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_STORAGE_CLASS)?;

        let tag_count: Option<TagCount> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_TAGGING_COUNT)?;

        let version_id: Option<ObjectVersionId> = http::parse_opt_header(req, &X_AMZ_FWD_HEADER_X_AMZ_VERSION_ID)?;

        Ok(Self {
            accept_ranges,
            body,
            bucket_key_enabled,
            cache_control,
            checksum_crc32,
            checksum_crc32c,
            checksum_sha1,
            checksum_sha256,
            content_disposition,
            content_encoding,
            content_language,
            content_length,
            content_range,
            content_type,
            delete_marker,
            e_tag,
            error_code,
            error_message,
            expiration,
            expires,
            last_modified,
            metadata,
            missing_meta,
            object_lock_legal_hold_status,
            object_lock_mode,
            object_lock_retain_until_date,
            parts_count,
            replication_status,
            request_charged,
            request_route,
            request_token,
            restore,
            sse_customer_algorithm,
            sse_customer_key_md5,
            ssekms_key_id,
            server_side_encryption,
            status_code,
            storage_class,
            tag_count,
            version_id,
        })
    }
}

impl TryInto<http::Response> for WriteGetObjectResponseOutput {
    type Error = S3Error;

    fn try_into(self) -> S3Result<http::Response> {
        Ok(http::Response::with_status(http::StatusCode::OK))
    }
}

#[derive(Clone)]
#[non_exhaustive]
pub enum OperationType {
    AbortMultipartUpload(&'static AbortMultipartUpload),
    CompleteMultipartUpload(&'static CompleteMultipartUpload),
    CopyObject(&'static CopyObject),
    CreateBucket(&'static CreateBucket),
    CreateMultipartUpload(&'static CreateMultipartUpload),
    DeleteBucket(&'static DeleteBucket),
    DeleteBucketAnalyticsConfiguration(&'static DeleteBucketAnalyticsConfiguration),
    DeleteBucketCors(&'static DeleteBucketCors),
    DeleteBucketEncryption(&'static DeleteBucketEncryption),
    DeleteBucketIntelligentTieringConfiguration(&'static DeleteBucketIntelligentTieringConfiguration),
    DeleteBucketInventoryConfiguration(&'static DeleteBucketInventoryConfiguration),
    DeleteBucketLifecycle(&'static DeleteBucketLifecycle),
    DeleteBucketMetricsConfiguration(&'static DeleteBucketMetricsConfiguration),
    DeleteBucketOwnershipControls(&'static DeleteBucketOwnershipControls),
    DeleteBucketPolicy(&'static DeleteBucketPolicy),
    DeleteBucketReplication(&'static DeleteBucketReplication),
    DeleteBucketTagging(&'static DeleteBucketTagging),
    DeleteBucketWebsite(&'static DeleteBucketWebsite),
    DeleteObject(&'static DeleteObject),
    DeleteObjectTagging(&'static DeleteObjectTagging),
    DeleteObjects(&'static DeleteObjects),
    DeletePublicAccessBlock(&'static DeletePublicAccessBlock),
    GetBucketAccelerateConfiguration(&'static GetBucketAccelerateConfiguration),
    GetBucketAcl(&'static GetBucketAcl),
    GetBucketAnalyticsConfiguration(&'static GetBucketAnalyticsConfiguration),
    GetBucketCors(&'static GetBucketCors),
    GetBucketEncryption(&'static GetBucketEncryption),
    GetBucketIntelligentTieringConfiguration(&'static GetBucketIntelligentTieringConfiguration),
    GetBucketInventoryConfiguration(&'static GetBucketInventoryConfiguration),
    GetBucketLifecycleConfiguration(&'static GetBucketLifecycleConfiguration),
    GetBucketLocation(&'static GetBucketLocation),
    GetBucketLogging(&'static GetBucketLogging),
    GetBucketMetricsConfiguration(&'static GetBucketMetricsConfiguration),
    GetBucketNotificationConfiguration(&'static GetBucketNotificationConfiguration),
    GetBucketOwnershipControls(&'static GetBucketOwnershipControls),
    GetBucketPolicy(&'static GetBucketPolicy),
    GetBucketPolicyStatus(&'static GetBucketPolicyStatus),
    GetBucketReplication(&'static GetBucketReplication),
    GetBucketRequestPayment(&'static GetBucketRequestPayment),
    GetBucketTagging(&'static GetBucketTagging),
    GetBucketVersioning(&'static GetBucketVersioning),
    GetBucketWebsite(&'static GetBucketWebsite),
    GetObject(&'static GetObject),
    GetObjectAcl(&'static GetObjectAcl),
    GetObjectAttributes(&'static GetObjectAttributes),
    GetObjectLegalHold(&'static GetObjectLegalHold),
    GetObjectLockConfiguration(&'static GetObjectLockConfiguration),
    GetObjectRetention(&'static GetObjectRetention),
    GetObjectTagging(&'static GetObjectTagging),
    GetObjectTorrent(&'static GetObjectTorrent),
    GetPublicAccessBlock(&'static GetPublicAccessBlock),
    HeadBucket(&'static HeadBucket),
    HeadObject(&'static HeadObject),
    ListBucketAnalyticsConfigurations(&'static ListBucketAnalyticsConfigurations),
    ListBucketIntelligentTieringConfigurations(&'static ListBucketIntelligentTieringConfigurations),
    ListBucketInventoryConfigurations(&'static ListBucketInventoryConfigurations),
    ListBucketMetricsConfigurations(&'static ListBucketMetricsConfigurations),
    ListBuckets(&'static ListBuckets),
    ListMultipartUploads(&'static ListMultipartUploads),
    ListObjectVersions(&'static ListObjectVersions),
    ListObjects(&'static ListObjects),
    ListObjectsV2(&'static ListObjectsV2),
    ListParts(&'static ListParts),
    PutBucketAccelerateConfiguration(&'static PutBucketAccelerateConfiguration),
    PutBucketAcl(&'static PutBucketAcl),
    PutBucketAnalyticsConfiguration(&'static PutBucketAnalyticsConfiguration),
    PutBucketCors(&'static PutBucketCors),
    PutBucketEncryption(&'static PutBucketEncryption),
    PutBucketIntelligentTieringConfiguration(&'static PutBucketIntelligentTieringConfiguration),
    PutBucketInventoryConfiguration(&'static PutBucketInventoryConfiguration),
    PutBucketLifecycleConfiguration(&'static PutBucketLifecycleConfiguration),
    PutBucketLogging(&'static PutBucketLogging),
    PutBucketMetricsConfiguration(&'static PutBucketMetricsConfiguration),
    PutBucketNotificationConfiguration(&'static PutBucketNotificationConfiguration),
    PutBucketOwnershipControls(&'static PutBucketOwnershipControls),
    PutBucketPolicy(&'static PutBucketPolicy),
    PutBucketReplication(&'static PutBucketReplication),
    PutBucketRequestPayment(&'static PutBucketRequestPayment),
    PutBucketTagging(&'static PutBucketTagging),
    PutBucketVersioning(&'static PutBucketVersioning),
    PutBucketWebsite(&'static PutBucketWebsite),
    PutObject(&'static PutObject),
    PutObjectAcl(&'static PutObjectAcl),
    PutObjectLegalHold(&'static PutObjectLegalHold),
    PutObjectLockConfiguration(&'static PutObjectLockConfiguration),
    PutObjectRetention(&'static PutObjectRetention),
    PutObjectTagging(&'static PutObjectTagging),
    PutPublicAccessBlock(&'static PutPublicAccessBlock),
    RestoreObject(&'static RestoreObject),
    SelectObjectContent(&'static SelectObjectContent),
    UploadPart(&'static UploadPart),
    UploadPartCopy(&'static UploadPartCopy),
    WriteGetObjectResponse(&'static WriteGetObjectResponse),
}

impl OperationType {
    pub async fn call(&self, s3: &Arc<dyn S3>, req: &mut http::Request) -> S3Result<http::Response> {
        match self {
            Self::AbortMultipartUpload(op) => <AbortMultipartUpload as super::Operation>::call(op, s3, req).await,
            Self::CompleteMultipartUpload(op) => <CompleteMultipartUpload as super::Operation>::call(op, s3, req).await,
            Self::CopyObject(op) => <CopyObject as super::Operation>::call(op, s3, req).await,
            Self::CreateBucket(op) => <CreateBucket as super::Operation>::call(op, s3, req).await,
            Self::CreateMultipartUpload(op) => <CreateMultipartUpload as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucket(op) => <DeleteBucket as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketAnalyticsConfiguration(op) => {
                <DeleteBucketAnalyticsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::DeleteBucketCors(op) => <DeleteBucketCors as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketEncryption(op) => <DeleteBucketEncryption as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketIntelligentTieringConfiguration(op) => {
                <DeleteBucketIntelligentTieringConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::DeleteBucketInventoryConfiguration(op) => {
                <DeleteBucketInventoryConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::DeleteBucketLifecycle(op) => <DeleteBucketLifecycle as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketMetricsConfiguration(op) => {
                <DeleteBucketMetricsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::DeleteBucketOwnershipControls(op) => {
                <DeleteBucketOwnershipControls as super::Operation>::call(op, s3, req).await
            }
            Self::DeleteBucketPolicy(op) => <DeleteBucketPolicy as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketReplication(op) => <DeleteBucketReplication as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketTagging(op) => <DeleteBucketTagging as super::Operation>::call(op, s3, req).await,
            Self::DeleteBucketWebsite(op) => <DeleteBucketWebsite as super::Operation>::call(op, s3, req).await,
            Self::DeleteObject(op) => <DeleteObject as super::Operation>::call(op, s3, req).await,
            Self::DeleteObjectTagging(op) => <DeleteObjectTagging as super::Operation>::call(op, s3, req).await,
            Self::DeleteObjects(op) => <DeleteObjects as super::Operation>::call(op, s3, req).await,
            Self::DeletePublicAccessBlock(op) => <DeletePublicAccessBlock as super::Operation>::call(op, s3, req).await,
            Self::GetBucketAccelerateConfiguration(op) => {
                <GetBucketAccelerateConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketAcl(op) => <GetBucketAcl as super::Operation>::call(op, s3, req).await,
            Self::GetBucketAnalyticsConfiguration(op) => {
                <GetBucketAnalyticsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketCors(op) => <GetBucketCors as super::Operation>::call(op, s3, req).await,
            Self::GetBucketEncryption(op) => <GetBucketEncryption as super::Operation>::call(op, s3, req).await,
            Self::GetBucketIntelligentTieringConfiguration(op) => {
                <GetBucketIntelligentTieringConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketInventoryConfiguration(op) => {
                <GetBucketInventoryConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketLifecycleConfiguration(op) => {
                <GetBucketLifecycleConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketLocation(op) => <GetBucketLocation as super::Operation>::call(op, s3, req).await,
            Self::GetBucketLogging(op) => <GetBucketLogging as super::Operation>::call(op, s3, req).await,
            Self::GetBucketMetricsConfiguration(op) => {
                <GetBucketMetricsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketNotificationConfiguration(op) => {
                <GetBucketNotificationConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::GetBucketOwnershipControls(op) => <GetBucketOwnershipControls as super::Operation>::call(op, s3, req).await,
            Self::GetBucketPolicy(op) => <GetBucketPolicy as super::Operation>::call(op, s3, req).await,
            Self::GetBucketPolicyStatus(op) => <GetBucketPolicyStatus as super::Operation>::call(op, s3, req).await,
            Self::GetBucketReplication(op) => <GetBucketReplication as super::Operation>::call(op, s3, req).await,
            Self::GetBucketRequestPayment(op) => <GetBucketRequestPayment as super::Operation>::call(op, s3, req).await,
            Self::GetBucketTagging(op) => <GetBucketTagging as super::Operation>::call(op, s3, req).await,
            Self::GetBucketVersioning(op) => <GetBucketVersioning as super::Operation>::call(op, s3, req).await,
            Self::GetBucketWebsite(op) => <GetBucketWebsite as super::Operation>::call(op, s3, req).await,
            Self::GetObject(op) => <GetObject as super::Operation>::call(op, s3, req).await,
            Self::GetObjectAcl(op) => <GetObjectAcl as super::Operation>::call(op, s3, req).await,
            Self::GetObjectAttributes(op) => <GetObjectAttributes as super::Operation>::call(op, s3, req).await,
            Self::GetObjectLegalHold(op) => <GetObjectLegalHold as super::Operation>::call(op, s3, req).await,
            Self::GetObjectLockConfiguration(op) => <GetObjectLockConfiguration as super::Operation>::call(op, s3, req).await,
            Self::GetObjectRetention(op) => <GetObjectRetention as super::Operation>::call(op, s3, req).await,
            Self::GetObjectTagging(op) => <GetObjectTagging as super::Operation>::call(op, s3, req).await,
            Self::GetObjectTorrent(op) => <GetObjectTorrent as super::Operation>::call(op, s3, req).await,
            Self::GetPublicAccessBlock(op) => <GetPublicAccessBlock as super::Operation>::call(op, s3, req).await,
            Self::HeadBucket(op) => <HeadBucket as super::Operation>::call(op, s3, req).await,
            Self::HeadObject(op) => <HeadObject as super::Operation>::call(op, s3, req).await,
            Self::ListBucketAnalyticsConfigurations(op) => {
                <ListBucketAnalyticsConfigurations as super::Operation>::call(op, s3, req).await
            }
            Self::ListBucketIntelligentTieringConfigurations(op) => {
                <ListBucketIntelligentTieringConfigurations as super::Operation>::call(op, s3, req).await
            }
            Self::ListBucketInventoryConfigurations(op) => {
                <ListBucketInventoryConfigurations as super::Operation>::call(op, s3, req).await
            }
            Self::ListBucketMetricsConfigurations(op) => {
                <ListBucketMetricsConfigurations as super::Operation>::call(op, s3, req).await
            }
            Self::ListBuckets(op) => <ListBuckets as super::Operation>::call(op, s3, req).await,
            Self::ListMultipartUploads(op) => <ListMultipartUploads as super::Operation>::call(op, s3, req).await,
            Self::ListObjectVersions(op) => <ListObjectVersions as super::Operation>::call(op, s3, req).await,
            Self::ListObjects(op) => <ListObjects as super::Operation>::call(op, s3, req).await,
            Self::ListObjectsV2(op) => <ListObjectsV2 as super::Operation>::call(op, s3, req).await,
            Self::ListParts(op) => <ListParts as super::Operation>::call(op, s3, req).await,
            Self::PutBucketAccelerateConfiguration(op) => {
                <PutBucketAccelerateConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketAcl(op) => <PutBucketAcl as super::Operation>::call(op, s3, req).await,
            Self::PutBucketAnalyticsConfiguration(op) => {
                <PutBucketAnalyticsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketCors(op) => <PutBucketCors as super::Operation>::call(op, s3, req).await,
            Self::PutBucketEncryption(op) => <PutBucketEncryption as super::Operation>::call(op, s3, req).await,
            Self::PutBucketIntelligentTieringConfiguration(op) => {
                <PutBucketIntelligentTieringConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketInventoryConfiguration(op) => {
                <PutBucketInventoryConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketLifecycleConfiguration(op) => {
                <PutBucketLifecycleConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketLogging(op) => <PutBucketLogging as super::Operation>::call(op, s3, req).await,
            Self::PutBucketMetricsConfiguration(op) => {
                <PutBucketMetricsConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketNotificationConfiguration(op) => {
                <PutBucketNotificationConfiguration as super::Operation>::call(op, s3, req).await
            }
            Self::PutBucketOwnershipControls(op) => <PutBucketOwnershipControls as super::Operation>::call(op, s3, req).await,
            Self::PutBucketPolicy(op) => <PutBucketPolicy as super::Operation>::call(op, s3, req).await,
            Self::PutBucketReplication(op) => <PutBucketReplication as super::Operation>::call(op, s3, req).await,
            Self::PutBucketRequestPayment(op) => <PutBucketRequestPayment as super::Operation>::call(op, s3, req).await,
            Self::PutBucketTagging(op) => <PutBucketTagging as super::Operation>::call(op, s3, req).await,
            Self::PutBucketVersioning(op) => <PutBucketVersioning as super::Operation>::call(op, s3, req).await,
            Self::PutBucketWebsite(op) => <PutBucketWebsite as super::Operation>::call(op, s3, req).await,
            Self::PutObject(op) => <PutObject as super::Operation>::call(op, s3, req).await,
            Self::PutObjectAcl(op) => <PutObjectAcl as super::Operation>::call(op, s3, req).await,
            Self::PutObjectLegalHold(op) => <PutObjectLegalHold as super::Operation>::call(op, s3, req).await,
            Self::PutObjectLockConfiguration(op) => <PutObjectLockConfiguration as super::Operation>::call(op, s3, req).await,
            Self::PutObjectRetention(op) => <PutObjectRetention as super::Operation>::call(op, s3, req).await,
            Self::PutObjectTagging(op) => <PutObjectTagging as super::Operation>::call(op, s3, req).await,
            Self::PutPublicAccessBlock(op) => <PutPublicAccessBlock as super::Operation>::call(op, s3, req).await,
            Self::RestoreObject(op) => <RestoreObject as super::Operation>::call(op, s3, req).await,
            Self::SelectObjectContent(op) => <SelectObjectContent as super::Operation>::call(op, s3, req).await,
            Self::UploadPart(op) => <UploadPart as super::Operation>::call(op, s3, req).await,
            Self::UploadPartCopy(op) => <UploadPartCopy as super::Operation>::call(op, s3, req).await,
            Self::WriteGetObjectResponse(op) => <WriteGetObjectResponse as super::Operation>::call(op, s3, req).await,
        }
    }

    pub fn as_dyn(self) -> &'static dyn super::Operation {
        match self {
            Self::AbortMultipartUpload(op) => op as &'static dyn super::Operation,
            Self::CompleteMultipartUpload(op) => op as &'static dyn super::Operation,
            Self::CopyObject(op) => op as &'static dyn super::Operation,
            Self::CreateBucket(op) => op as &'static dyn super::Operation,
            Self::CreateMultipartUpload(op) => op as &'static dyn super::Operation,
            Self::DeleteBucket(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketAnalyticsConfiguration(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketCors(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketEncryption(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketIntelligentTieringConfiguration(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketInventoryConfiguration(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketLifecycle(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketMetricsConfiguration(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketOwnershipControls(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketPolicy(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketReplication(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketTagging(op) => op as &'static dyn super::Operation,
            Self::DeleteBucketWebsite(op) => op as &'static dyn super::Operation,
            Self::DeleteObject(op) => op as &'static dyn super::Operation,
            Self::DeleteObjectTagging(op) => op as &'static dyn super::Operation,
            Self::DeleteObjects(op) => op as &'static dyn super::Operation,
            Self::DeletePublicAccessBlock(op) => op as &'static dyn super::Operation,
            Self::GetBucketAccelerateConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketAcl(op) => op as &'static dyn super::Operation,
            Self::GetBucketAnalyticsConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketCors(op) => op as &'static dyn super::Operation,
            Self::GetBucketEncryption(op) => op as &'static dyn super::Operation,
            Self::GetBucketIntelligentTieringConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketInventoryConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketLifecycleConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketLocation(op) => op as &'static dyn super::Operation,
            Self::GetBucketLogging(op) => op as &'static dyn super::Operation,
            Self::GetBucketMetricsConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketNotificationConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetBucketOwnershipControls(op) => op as &'static dyn super::Operation,
            Self::GetBucketPolicy(op) => op as &'static dyn super::Operation,
            Self::GetBucketPolicyStatus(op) => op as &'static dyn super::Operation,
            Self::GetBucketReplication(op) => op as &'static dyn super::Operation,
            Self::GetBucketRequestPayment(op) => op as &'static dyn super::Operation,
            Self::GetBucketTagging(op) => op as &'static dyn super::Operation,
            Self::GetBucketVersioning(op) => op as &'static dyn super::Operation,
            Self::GetBucketWebsite(op) => op as &'static dyn super::Operation,
            Self::GetObject(op) => op as &'static dyn super::Operation,
            Self::GetObjectAcl(op) => op as &'static dyn super::Operation,
            Self::GetObjectAttributes(op) => op as &'static dyn super::Operation,
            Self::GetObjectLegalHold(op) => op as &'static dyn super::Operation,
            Self::GetObjectLockConfiguration(op) => op as &'static dyn super::Operation,
            Self::GetObjectRetention(op) => op as &'static dyn super::Operation,
            Self::GetObjectTagging(op) => op as &'static dyn super::Operation,
            Self::GetObjectTorrent(op) => op as &'static dyn super::Operation,
            Self::GetPublicAccessBlock(op) => op as &'static dyn super::Operation,
            Self::HeadBucket(op) => op as &'static dyn super::Operation,
            Self::HeadObject(op) => op as &'static dyn super::Operation,
            Self::ListBucketAnalyticsConfigurations(op) => op as &'static dyn super::Operation,
            Self::ListBucketIntelligentTieringConfigurations(op) => op as &'static dyn super::Operation,
            Self::ListBucketInventoryConfigurations(op) => op as &'static dyn super::Operation,
            Self::ListBucketMetricsConfigurations(op) => op as &'static dyn super::Operation,
            Self::ListBuckets(op) => op as &'static dyn super::Operation,
            Self::ListMultipartUploads(op) => op as &'static dyn super::Operation,
            Self::ListObjectVersions(op) => op as &'static dyn super::Operation,
            Self::ListObjects(op) => op as &'static dyn super::Operation,
            Self::ListObjectsV2(op) => op as &'static dyn super::Operation,
            Self::ListParts(op) => op as &'static dyn super::Operation,
            Self::PutBucketAccelerateConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketAcl(op) => op as &'static dyn super::Operation,
            Self::PutBucketAnalyticsConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketCors(op) => op as &'static dyn super::Operation,
            Self::PutBucketEncryption(op) => op as &'static dyn super::Operation,
            Self::PutBucketIntelligentTieringConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketInventoryConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketLifecycleConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketLogging(op) => op as &'static dyn super::Operation,
            Self::PutBucketMetricsConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketNotificationConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutBucketOwnershipControls(op) => op as &'static dyn super::Operation,
            Self::PutBucketPolicy(op) => op as &'static dyn super::Operation,
            Self::PutBucketReplication(op) => op as &'static dyn super::Operation,
            Self::PutBucketRequestPayment(op) => op as &'static dyn super::Operation,
            Self::PutBucketTagging(op) => op as &'static dyn super::Operation,
            Self::PutBucketVersioning(op) => op as &'static dyn super::Operation,
            Self::PutBucketWebsite(op) => op as &'static dyn super::Operation,
            Self::PutObject(op) => op as &'static dyn super::Operation,
            Self::PutObjectAcl(op) => op as &'static dyn super::Operation,
            Self::PutObjectLegalHold(op) => op as &'static dyn super::Operation,
            Self::PutObjectLockConfiguration(op) => op as &'static dyn super::Operation,
            Self::PutObjectRetention(op) => op as &'static dyn super::Operation,
            Self::PutObjectTagging(op) => op as &'static dyn super::Operation,
            Self::PutPublicAccessBlock(op) => op as &'static dyn super::Operation,
            Self::RestoreObject(op) => op as &'static dyn super::Operation,
            Self::SelectObjectContent(op) => op as &'static dyn super::Operation,
            Self::UploadPart(op) => op as &'static dyn super::Operation,
            Self::UploadPartCopy(op) => op as &'static dyn super::Operation,
            Self::WriteGetObjectResponse(op) => op as &'static dyn super::Operation,
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            Self::AbortMultipartUpload(_) => "AbortMultipartUpload",
            Self::CompleteMultipartUpload(_) => "CompleteMultipartUpload",
            Self::CopyObject(_) => "CopyObject",
            Self::CreateBucket(_) => "CreateBucket",
            Self::CreateMultipartUpload(_) => "CreateMultipartUpload",
            Self::DeleteBucket(_) => "DeleteBucket",
            Self::DeleteBucketAnalyticsConfiguration(_) => "DeleteBucketAnalyticsConfiguration",
            Self::DeleteBucketCors(_) => "DeleteBucketCors",
            Self::DeleteBucketEncryption(_) => "DeleteBucketEncryption",
            Self::DeleteBucketIntelligentTieringConfiguration(_) => "DeleteBucketIntelligentTieringConfiguration",
            Self::DeleteBucketInventoryConfiguration(_) => "DeleteBucketInventoryConfiguration",
            Self::DeleteBucketLifecycle(_) => "DeleteBucketLifecycle",
            Self::DeleteBucketMetricsConfiguration(_) => "DeleteBucketMetricsConfiguration",
            Self::DeleteBucketOwnershipControls(_) => "DeleteBucketOwnershipControls",
            Self::DeleteBucketPolicy(_) => "DeleteBucketPolicy",
            Self::DeleteBucketReplication(_) => "DeleteBucketReplication",
            Self::DeleteBucketTagging(_) => "DeleteBucketTagging",
            Self::DeleteBucketWebsite(_) => "DeleteBucketWebsite",
            Self::DeleteObject(_) => "DeleteObject",
            Self::DeleteObjectTagging(_) => "DeleteObjectTagging",
            Self::DeleteObjects(_) => "DeleteObjects",
            Self::DeletePublicAccessBlock(_) => "DeletePublicAccessBlock",
            Self::GetBucketAccelerateConfiguration(_) => "GetBucketAccelerateConfiguration",
            Self::GetBucketAcl(_) => "GetBucketAcl",
            Self::GetBucketAnalyticsConfiguration(_) => "GetBucketAnalyticsConfiguration",
            Self::GetBucketCors(_) => "GetBucketCors",
            Self::GetBucketEncryption(_) => "GetBucketEncryption",
            Self::GetBucketIntelligentTieringConfiguration(_) => "GetBucketIntelligentTieringConfiguration",
            Self::GetBucketInventoryConfiguration(_) => "GetBucketInventoryConfiguration",
            Self::GetBucketLifecycleConfiguration(_) => "GetBucketLifecycleConfiguration",
            Self::GetBucketLocation(_) => "GetBucketLocation",
            Self::GetBucketLogging(_) => "GetBucketLogging",
            Self::GetBucketMetricsConfiguration(_) => "GetBucketMetricsConfiguration",
            Self::GetBucketNotificationConfiguration(_) => "GetBucketNotificationConfiguration",
            Self::GetBucketOwnershipControls(_) => "GetBucketOwnershipControls",
            Self::GetBucketPolicy(_) => "GetBucketPolicy",
            Self::GetBucketPolicyStatus(_) => "GetBucketPolicyStatus",
            Self::GetBucketReplication(_) => "GetBucketReplication",
            Self::GetBucketRequestPayment(_) => "GetBucketRequestPayment",
            Self::GetBucketTagging(_) => "GetBucketTagging",
            Self::GetBucketVersioning(_) => "GetBucketVersioning",
            Self::GetBucketWebsite(_) => "GetBucketWebsite",
            Self::GetObject(_) => "GetObject",
            Self::GetObjectAcl(_) => "GetObjectAcl",
            Self::GetObjectAttributes(_) => "GetObjectAttributes",
            Self::GetObjectLegalHold(_) => "GetObjectLegalHold",
            Self::GetObjectLockConfiguration(_) => "GetObjectLockConfiguration",
            Self::GetObjectRetention(_) => "GetObjectRetention",
            Self::GetObjectTagging(_) => "GetObjectTagging",
            Self::GetObjectTorrent(_) => "GetObjectTorrent",
            Self::GetPublicAccessBlock(_) => "GetPublicAccessBlock",
            Self::HeadBucket(_) => "HeadBucket",
            Self::HeadObject(_) => "HeadObject",
            Self::ListBucketAnalyticsConfigurations(_) => "ListBucketAnalyticsConfigurations",
            Self::ListBucketIntelligentTieringConfigurations(_) => "ListBucketIntelligentTieringConfigurations",
            Self::ListBucketInventoryConfigurations(_) => "ListBucketInventoryConfigurations",
            Self::ListBucketMetricsConfigurations(_) => "ListBucketMetricsConfigurations",
            Self::ListBuckets(_) => "ListBuckets",
            Self::ListMultipartUploads(_) => "ListMultipartUploads",
            Self::ListObjectVersions(_) => "ListObjectVersions",
            Self::ListObjects(_) => "ListObjects",
            Self::ListObjectsV2(_) => "ListObjectsV2",
            Self::ListParts(_) => "ListParts",
            Self::PutBucketAccelerateConfiguration(_) => "PutBucketAccelerateConfiguration",
            Self::PutBucketAcl(_) => "PutBucketAcl",
            Self::PutBucketAnalyticsConfiguration(_) => "PutBucketAnalyticsConfiguration",
            Self::PutBucketCors(_) => "PutBucketCors",
            Self::PutBucketEncryption(_) => "PutBucketEncryption",
            Self::PutBucketIntelligentTieringConfiguration(_) => "PutBucketIntelligentTieringConfiguration",
            Self::PutBucketInventoryConfiguration(_) => "PutBucketInventoryConfiguration",
            Self::PutBucketLifecycleConfiguration(_) => "PutBucketLifecycleConfiguration",
            Self::PutBucketLogging(_) => "PutBucketLogging",
            Self::PutBucketMetricsConfiguration(_) => "PutBucketMetricsConfiguration",
            Self::PutBucketNotificationConfiguration(_) => "PutBucketNotificationConfiguration",
            Self::PutBucketOwnershipControls(_) => "PutBucketOwnershipControls",
            Self::PutBucketPolicy(_) => "PutBucketPolicy",
            Self::PutBucketReplication(_) => "PutBucketReplication",
            Self::PutBucketRequestPayment(_) => "PutBucketRequestPayment",
            Self::PutBucketTagging(_) => "PutBucketTagging",
            Self::PutBucketVersioning(_) => "PutBucketVersioning",
            Self::PutBucketWebsite(_) => "PutBucketWebsite",
            Self::PutObject(_) => "PutObject",
            Self::PutObjectAcl(_) => "PutObjectAcl",
            Self::PutObjectLegalHold(_) => "PutObjectLegalHold",
            Self::PutObjectLockConfiguration(_) => "PutObjectLockConfiguration",
            Self::PutObjectRetention(_) => "PutObjectRetention",
            Self::PutObjectTagging(_) => "PutObjectTagging",
            Self::PutPublicAccessBlock(_) => "PutPublicAccessBlock",
            Self::RestoreObject(_) => "RestoreObject",
            Self::SelectObjectContent(_) => "SelectObjectContent",
            Self::UploadPart(_) => "UploadPart",
            Self::UploadPartCopy(_) => "UploadPartCopy",
            Self::WriteGetObjectResponse(_) => "WriteGetObjectResponse",
        }
    }
}

impl From<&'static AbortMultipartUpload> for OperationType {
    fn from(op: &'static AbortMultipartUpload) -> Self {
        Self::AbortMultipartUpload(op)
    }
}

impl From<&'static CompleteMultipartUpload> for OperationType {
    fn from(op: &'static CompleteMultipartUpload) -> Self {
        Self::CompleteMultipartUpload(op)
    }
}

impl From<&'static CopyObject> for OperationType {
    fn from(op: &'static CopyObject) -> Self {
        Self::CopyObject(op)
    }
}

impl From<&'static CreateBucket> for OperationType {
    fn from(op: &'static CreateBucket) -> Self {
        Self::CreateBucket(op)
    }
}

impl From<&'static CreateMultipartUpload> for OperationType {
    fn from(op: &'static CreateMultipartUpload) -> Self {
        Self::CreateMultipartUpload(op)
    }
}

impl From<&'static DeleteBucket> for OperationType {
    fn from(op: &'static DeleteBucket) -> Self {
        Self::DeleteBucket(op)
    }
}

impl From<&'static DeleteBucketAnalyticsConfiguration> for OperationType {
    fn from(op: &'static DeleteBucketAnalyticsConfiguration) -> Self {
        Self::DeleteBucketAnalyticsConfiguration(op)
    }
}

impl From<&'static DeleteBucketCors> for OperationType {
    fn from(op: &'static DeleteBucketCors) -> Self {
        Self::DeleteBucketCors(op)
    }
}

impl From<&'static DeleteBucketEncryption> for OperationType {
    fn from(op: &'static DeleteBucketEncryption) -> Self {
        Self::DeleteBucketEncryption(op)
    }
}

impl From<&'static DeleteBucketIntelligentTieringConfiguration> for OperationType {
    fn from(op: &'static DeleteBucketIntelligentTieringConfiguration) -> Self {
        Self::DeleteBucketIntelligentTieringConfiguration(op)
    }
}

impl From<&'static DeleteBucketInventoryConfiguration> for OperationType {
    fn from(op: &'static DeleteBucketInventoryConfiguration) -> Self {
        Self::DeleteBucketInventoryConfiguration(op)
    }
}

impl From<&'static DeleteBucketLifecycle> for OperationType {
    fn from(op: &'static DeleteBucketLifecycle) -> Self {
        Self::DeleteBucketLifecycle(op)
    }
}

impl From<&'static DeleteBucketMetricsConfiguration> for OperationType {
    fn from(op: &'static DeleteBucketMetricsConfiguration) -> Self {
        Self::DeleteBucketMetricsConfiguration(op)
    }
}

impl From<&'static DeleteBucketOwnershipControls> for OperationType {
    fn from(op: &'static DeleteBucketOwnershipControls) -> Self {
        Self::DeleteBucketOwnershipControls(op)
    }
}

impl From<&'static DeleteBucketPolicy> for OperationType {
    fn from(op: &'static DeleteBucketPolicy) -> Self {
        Self::DeleteBucketPolicy(op)
    }
}

impl From<&'static DeleteBucketReplication> for OperationType {
    fn from(op: &'static DeleteBucketReplication) -> Self {
        Self::DeleteBucketReplication(op)
    }
}

impl From<&'static DeleteBucketTagging> for OperationType {
    fn from(op: &'static DeleteBucketTagging) -> Self {
        Self::DeleteBucketTagging(op)
    }
}

impl From<&'static DeleteBucketWebsite> for OperationType {
    fn from(op: &'static DeleteBucketWebsite) -> Self {
        Self::DeleteBucketWebsite(op)
    }
}

impl From<&'static DeleteObject> for OperationType {
    fn from(op: &'static DeleteObject) -> Self {
        Self::DeleteObject(op)
    }
}

impl From<&'static DeleteObjectTagging> for OperationType {
    fn from(op: &'static DeleteObjectTagging) -> Self {
        Self::DeleteObjectTagging(op)
    }
}

impl From<&'static DeleteObjects> for OperationType {
    fn from(op: &'static DeleteObjects) -> Self {
        Self::DeleteObjects(op)
    }
}

impl From<&'static DeletePublicAccessBlock> for OperationType {
    fn from(op: &'static DeletePublicAccessBlock) -> Self {
        Self::DeletePublicAccessBlock(op)
    }
}

impl From<&'static GetBucketAccelerateConfiguration> for OperationType {
    fn from(op: &'static GetBucketAccelerateConfiguration) -> Self {
        Self::GetBucketAccelerateConfiguration(op)
    }
}

impl From<&'static GetBucketAcl> for OperationType {
    fn from(op: &'static GetBucketAcl) -> Self {
        Self::GetBucketAcl(op)
    }
}

impl From<&'static GetBucketAnalyticsConfiguration> for OperationType {
    fn from(op: &'static GetBucketAnalyticsConfiguration) -> Self {
        Self::GetBucketAnalyticsConfiguration(op)
    }
}

impl From<&'static GetBucketCors> for OperationType {
    fn from(op: &'static GetBucketCors) -> Self {
        Self::GetBucketCors(op)
    }
}

impl From<&'static GetBucketEncryption> for OperationType {
    fn from(op: &'static GetBucketEncryption) -> Self {
        Self::GetBucketEncryption(op)
    }
}

impl From<&'static GetBucketIntelligentTieringConfiguration> for OperationType {
    fn from(op: &'static GetBucketIntelligentTieringConfiguration) -> Self {
        Self::GetBucketIntelligentTieringConfiguration(op)
    }
}

impl From<&'static GetBucketInventoryConfiguration> for OperationType {
    fn from(op: &'static GetBucketInventoryConfiguration) -> Self {
        Self::GetBucketInventoryConfiguration(op)
    }
}

impl From<&'static GetBucketLifecycleConfiguration> for OperationType {
    fn from(op: &'static GetBucketLifecycleConfiguration) -> Self {
        Self::GetBucketLifecycleConfiguration(op)
    }
}

impl From<&'static GetBucketLocation> for OperationType {
    fn from(op: &'static GetBucketLocation) -> Self {
        Self::GetBucketLocation(op)
    }
}

impl From<&'static GetBucketLogging> for OperationType {
    fn from(op: &'static GetBucketLogging) -> Self {
        Self::GetBucketLogging(op)
    }
}

impl From<&'static GetBucketMetricsConfiguration> for OperationType {
    fn from(op: &'static GetBucketMetricsConfiguration) -> Self {
        Self::GetBucketMetricsConfiguration(op)
    }
}

impl From<&'static GetBucketNotificationConfiguration> for OperationType {
    fn from(op: &'static GetBucketNotificationConfiguration) -> Self {
        Self::GetBucketNotificationConfiguration(op)
    }
}

impl From<&'static GetBucketOwnershipControls> for OperationType {
    fn from(op: &'static GetBucketOwnershipControls) -> Self {
        Self::GetBucketOwnershipControls(op)
    }
}

impl From<&'static GetBucketPolicy> for OperationType {
    fn from(op: &'static GetBucketPolicy) -> Self {
        Self::GetBucketPolicy(op)
    }
}

impl From<&'static GetBucketPolicyStatus> for OperationType {
    fn from(op: &'static GetBucketPolicyStatus) -> Self {
        Self::GetBucketPolicyStatus(op)
    }
}

impl From<&'static GetBucketReplication> for OperationType {
    fn from(op: &'static GetBucketReplication) -> Self {
        Self::GetBucketReplication(op)
    }
}

impl From<&'static GetBucketRequestPayment> for OperationType {
    fn from(op: &'static GetBucketRequestPayment) -> Self {
        Self::GetBucketRequestPayment(op)
    }
}

impl From<&'static GetBucketTagging> for OperationType {
    fn from(op: &'static GetBucketTagging) -> Self {
        Self::GetBucketTagging(op)
    }
}

impl From<&'static GetBucketVersioning> for OperationType {
    fn from(op: &'static GetBucketVersioning) -> Self {
        Self::GetBucketVersioning(op)
    }
}

impl From<&'static GetBucketWebsite> for OperationType {
    fn from(op: &'static GetBucketWebsite) -> Self {
        Self::GetBucketWebsite(op)
    }
}

impl From<&'static GetObject> for OperationType {
    fn from(op: &'static GetObject) -> Self {
        Self::GetObject(op)
    }
}

impl From<&'static GetObjectAcl> for OperationType {
    fn from(op: &'static GetObjectAcl) -> Self {
        Self::GetObjectAcl(op)
    }
}

impl From<&'static GetObjectAttributes> for OperationType {
    fn from(op: &'static GetObjectAttributes) -> Self {
        Self::GetObjectAttributes(op)
    }
}

impl From<&'static GetObjectLegalHold> for OperationType {
    fn from(op: &'static GetObjectLegalHold) -> Self {
        Self::GetObjectLegalHold(op)
    }
}

impl From<&'static GetObjectLockConfiguration> for OperationType {
    fn from(op: &'static GetObjectLockConfiguration) -> Self {
        Self::GetObjectLockConfiguration(op)
    }
}

impl From<&'static GetObjectRetention> for OperationType {
    fn from(op: &'static GetObjectRetention) -> Self {
        Self::GetObjectRetention(op)
    }
}

impl From<&'static GetObjectTagging> for OperationType {
    fn from(op: &'static GetObjectTagging) -> Self {
        Self::GetObjectTagging(op)
    }
}

impl From<&'static GetObjectTorrent> for OperationType {
    fn from(op: &'static GetObjectTorrent) -> Self {
        Self::GetObjectTorrent(op)
    }
}

impl From<&'static GetPublicAccessBlock> for OperationType {
    fn from(op: &'static GetPublicAccessBlock) -> Self {
        Self::GetPublicAccessBlock(op)
    }
}

impl From<&'static HeadBucket> for OperationType {
    fn from(op: &'static HeadBucket) -> Self {
        Self::HeadBucket(op)
    }
}

impl From<&'static HeadObject> for OperationType {
    fn from(op: &'static HeadObject) -> Self {
        Self::HeadObject(op)
    }
}

impl From<&'static ListBucketAnalyticsConfigurations> for OperationType {
    fn from(op: &'static ListBucketAnalyticsConfigurations) -> Self {
        Self::ListBucketAnalyticsConfigurations(op)
    }
}

impl From<&'static ListBucketIntelligentTieringConfigurations> for OperationType {
    fn from(op: &'static ListBucketIntelligentTieringConfigurations) -> Self {
        Self::ListBucketIntelligentTieringConfigurations(op)
    }
}

impl From<&'static ListBucketInventoryConfigurations> for OperationType {
    fn from(op: &'static ListBucketInventoryConfigurations) -> Self {
        Self::ListBucketInventoryConfigurations(op)
    }
}

impl From<&'static ListBucketMetricsConfigurations> for OperationType {
    fn from(op: &'static ListBucketMetricsConfigurations) -> Self {
        Self::ListBucketMetricsConfigurations(op)
    }
}

impl From<&'static ListBuckets> for OperationType {
    fn from(op: &'static ListBuckets) -> Self {
        Self::ListBuckets(op)
    }
}

impl From<&'static ListMultipartUploads> for OperationType {
    fn from(op: &'static ListMultipartUploads) -> Self {
        Self::ListMultipartUploads(op)
    }
}

impl From<&'static ListObjectVersions> for OperationType {
    fn from(op: &'static ListObjectVersions) -> Self {
        Self::ListObjectVersions(op)
    }
}

impl From<&'static ListObjects> for OperationType {
    fn from(op: &'static ListObjects) -> Self {
        Self::ListObjects(op)
    }
}

impl From<&'static ListObjectsV2> for OperationType {
    fn from(op: &'static ListObjectsV2) -> Self {
        Self::ListObjectsV2(op)
    }
}

impl From<&'static ListParts> for OperationType {
    fn from(op: &'static ListParts) -> Self {
        Self::ListParts(op)
    }
}

impl From<&'static PutBucketAccelerateConfiguration> for OperationType {
    fn from(op: &'static PutBucketAccelerateConfiguration) -> Self {
        Self::PutBucketAccelerateConfiguration(op)
    }
}

impl From<&'static PutBucketAcl> for OperationType {
    fn from(op: &'static PutBucketAcl) -> Self {
        Self::PutBucketAcl(op)
    }
}

impl From<&'static PutBucketAnalyticsConfiguration> for OperationType {
    fn from(op: &'static PutBucketAnalyticsConfiguration) -> Self {
        Self::PutBucketAnalyticsConfiguration(op)
    }
}

impl From<&'static PutBucketCors> for OperationType {
    fn from(op: &'static PutBucketCors) -> Self {
        Self::PutBucketCors(op)
    }
}

impl From<&'static PutBucketEncryption> for OperationType {
    fn from(op: &'static PutBucketEncryption) -> Self {
        Self::PutBucketEncryption(op)
    }
}

impl From<&'static PutBucketIntelligentTieringConfiguration> for OperationType {
    fn from(op: &'static PutBucketIntelligentTieringConfiguration) -> Self {
        Self::PutBucketIntelligentTieringConfiguration(op)
    }
}

impl From<&'static PutBucketInventoryConfiguration> for OperationType {
    fn from(op: &'static PutBucketInventoryConfiguration) -> Self {
        Self::PutBucketInventoryConfiguration(op)
    }
}

impl From<&'static PutBucketLifecycleConfiguration> for OperationType {
    fn from(op: &'static PutBucketLifecycleConfiguration) -> Self {
        Self::PutBucketLifecycleConfiguration(op)
    }
}

impl From<&'static PutBucketLogging> for OperationType {
    fn from(op: &'static PutBucketLogging) -> Self {
        Self::PutBucketLogging(op)
    }
}

impl From<&'static PutBucketMetricsConfiguration> for OperationType {
    fn from(op: &'static PutBucketMetricsConfiguration) -> Self {
        Self::PutBucketMetricsConfiguration(op)
    }
}

impl From<&'static PutBucketNotificationConfiguration> for OperationType {
    fn from(op: &'static PutBucketNotificationConfiguration) -> Self {
        Self::PutBucketNotificationConfiguration(op)
    }
}

impl From<&'static PutBucketOwnershipControls> for OperationType {
    fn from(op: &'static PutBucketOwnershipControls) -> Self {
        Self::PutBucketOwnershipControls(op)
    }
}

impl From<&'static PutBucketPolicy> for OperationType {
    fn from(op: &'static PutBucketPolicy) -> Self {
        Self::PutBucketPolicy(op)
    }
}

impl From<&'static PutBucketReplication> for OperationType {
    fn from(op: &'static PutBucketReplication) -> Self {
        Self::PutBucketReplication(op)
    }
}

impl From<&'static PutBucketRequestPayment> for OperationType {
    fn from(op: &'static PutBucketRequestPayment) -> Self {
        Self::PutBucketRequestPayment(op)
    }
}

impl From<&'static PutBucketTagging> for OperationType {
    fn from(op: &'static PutBucketTagging) -> Self {
        Self::PutBucketTagging(op)
    }
}

impl From<&'static PutBucketVersioning> for OperationType {
    fn from(op: &'static PutBucketVersioning) -> Self {
        Self::PutBucketVersioning(op)
    }
}

impl From<&'static PutBucketWebsite> for OperationType {
    fn from(op: &'static PutBucketWebsite) -> Self {
        Self::PutBucketWebsite(op)
    }
}

impl From<&'static PutObject> for OperationType {
    fn from(op: &'static PutObject) -> Self {
        Self::PutObject(op)
    }
}

impl From<&'static PutObjectAcl> for OperationType {
    fn from(op: &'static PutObjectAcl) -> Self {
        Self::PutObjectAcl(op)
    }
}

impl From<&'static PutObjectLegalHold> for OperationType {
    fn from(op: &'static PutObjectLegalHold) -> Self {
        Self::PutObjectLegalHold(op)
    }
}

impl From<&'static PutObjectLockConfiguration> for OperationType {
    fn from(op: &'static PutObjectLockConfiguration) -> Self {
        Self::PutObjectLockConfiguration(op)
    }
}

impl From<&'static PutObjectRetention> for OperationType {
    fn from(op: &'static PutObjectRetention) -> Self {
        Self::PutObjectRetention(op)
    }
}

impl From<&'static PutObjectTagging> for OperationType {
    fn from(op: &'static PutObjectTagging) -> Self {
        Self::PutObjectTagging(op)
    }
}

impl From<&'static PutPublicAccessBlock> for OperationType {
    fn from(op: &'static PutPublicAccessBlock) -> Self {
        Self::PutPublicAccessBlock(op)
    }
}

impl From<&'static RestoreObject> for OperationType {
    fn from(op: &'static RestoreObject) -> Self {
        Self::RestoreObject(op)
    }
}

impl From<&'static SelectObjectContent> for OperationType {
    fn from(op: &'static SelectObjectContent) -> Self {
        Self::SelectObjectContent(op)
    }
}

impl From<&'static UploadPart> for OperationType {
    fn from(op: &'static UploadPart) -> Self {
        Self::UploadPart(op)
    }
}

impl From<&'static UploadPartCopy> for OperationType {
    fn from(op: &'static UploadPartCopy) -> Self {
        Self::UploadPartCopy(op)
    }
}

impl From<&'static WriteGetObjectResponse> for OperationType {
    fn from(op: &'static WriteGetObjectResponse) -> Self {
        Self::WriteGetObjectResponse(op)
    }
}

pub fn resolve_route(req: &http::Request, s3_path: &S3Path, qs: Option<&http::OrderedQs>) -> S3Result<(OperationType, bool)> {
    match req.method {
        hyper::Method::HEAD => match s3_path {
            S3Path::Root => Err(super::unknown_operation()),
            S3Path::Bucket { .. } => Ok((OperationType::from(&HeadBucket), false)),
            S3Path::Object { .. } => Ok((OperationType::from(&HeadObject), false)),
        },
        hyper::Method::GET => match s3_path {
            S3Path::Root => Ok((OperationType::from(&ListBuckets), false)),
            S3Path::Bucket { .. } => {
                if let Some(qs) = qs {
                    if qs.has("analytics") {
                        return Ok((OperationType::from(&GetBucketAnalyticsConfiguration), false));
                    }
                    if qs.has("intelligent-tiering") {
                        return Ok((OperationType::from(&GetBucketIntelligentTieringConfiguration), false));
                    }
                    if qs.has("inventory") {
                        return Ok((OperationType::from(&GetBucketInventoryConfiguration), false));
                    }
                    if qs.has("metrics") {
                        return Ok((OperationType::from(&GetBucketMetricsConfiguration), false));
                    }
                    if qs.has("accelerate") {
                        return Ok((OperationType::from(&GetBucketAccelerateConfiguration), false));
                    }
                    if qs.has("acl") {
                        return Ok((OperationType::from(&GetBucketAcl), false));
                    }
                    if qs.has("cors") {
                        return Ok((OperationType::from(&GetBucketCors), false));
                    }
                    if qs.has("encryption") {
                        return Ok((OperationType::from(&GetBucketEncryption), false));
                    }
                    if qs.has("lifecycle") {
                        return Ok((OperationType::from(&GetBucketLifecycleConfiguration), false));
                    }
                    if qs.has("location") {
                        return Ok((OperationType::from(&GetBucketLocation), false));
                    }
                    if qs.has("logging") {
                        return Ok((OperationType::from(&GetBucketLogging), false));
                    }
                    if qs.has("notification") {
                        return Ok((OperationType::from(&GetBucketNotificationConfiguration), false));
                    }
                    if qs.has("ownershipControls") {
                        return Ok((OperationType::from(&GetBucketOwnershipControls), false));
                    }
                    if qs.has("policy") {
                        return Ok((OperationType::from(&GetBucketPolicy), false));
                    }
                    if qs.has("policyStatus") {
                        return Ok((OperationType::from(&GetBucketPolicyStatus), false));
                    }
                    if qs.has("replication") {
                        return Ok((OperationType::from(&GetBucketReplication), false));
                    }
                    if qs.has("requestPayment") {
                        return Ok((OperationType::from(&GetBucketRequestPayment), false));
                    }
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&GetBucketTagging), false));
                    }
                    if qs.has("versioning") {
                        return Ok((OperationType::from(&GetBucketVersioning), false));
                    }
                    if qs.has("website") {
                        return Ok((OperationType::from(&GetBucketWebsite), false));
                    }
                    if qs.has("object-lock") {
                        return Ok((OperationType::from(&GetObjectLockConfiguration), false));
                    }
                    if qs.has("publicAccessBlock") {
                        return Ok((OperationType::from(&GetPublicAccessBlock), false));
                    }
                    if qs.has("analytics") {
                        return Ok((OperationType::from(&ListBucketAnalyticsConfigurations), false));
                    }
                    if qs.has("intelligent-tiering") {
                        return Ok((OperationType::from(&ListBucketIntelligentTieringConfigurations), false));
                    }
                    if qs.has("inventory") {
                        return Ok((OperationType::from(&ListBucketInventoryConfigurations), false));
                    }
                    if qs.has("metrics") {
                        return Ok((OperationType::from(&ListBucketMetricsConfigurations), false));
                    }
                    if qs.has("uploads") {
                        return Ok((OperationType::from(&ListMultipartUploads), false));
                    }
                    if qs.has("versions") {
                        return Ok((OperationType::from(&ListObjectVersions), false));
                    }
                    if super::check_query_pattern(qs, "list-type", "2") {
                        return Ok((OperationType::from(&ListObjectsV2), false));
                    }
                }
                Ok((OperationType::from(&ListObjects), false))
            }
            S3Path::Object { .. } => {
                if let Some(qs) = qs {
                    if qs.has("attributes") {
                        return Ok((OperationType::from(&GetObjectAttributes), false));
                    }
                    if qs.has("acl") {
                        return Ok((OperationType::from(&GetObjectAcl), false));
                    }
                    if qs.has("legal-hold") {
                        return Ok((OperationType::from(&GetObjectLegalHold), false));
                    }
                    if qs.has("retention") {
                        return Ok((OperationType::from(&GetObjectRetention), false));
                    }
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&GetObjectTagging), false));
                    }
                    if qs.has("torrent") {
                        return Ok((OperationType::from(&GetObjectTorrent), false));
                    }
                }
                if let Some(qs) = qs {
                    if qs.has("uploadId") {
                        return Ok((OperationType::from(&ListParts), false));
                    }
                }
                Ok((OperationType::from(&GetObject), false))
            }
        },
        hyper::Method::POST => match s3_path {
            S3Path::Root => Err(super::unknown_operation()),
            S3Path::Bucket { .. } => {
                if let Some(qs) = qs {
                    if qs.has("delete") {
                        return Ok((OperationType::from(&DeleteObjects), true));
                    }
                }
                if req.headers.contains_key("x-amz-request-route") && req.headers.contains_key("x-amz-request-token") {
                    return Ok((OperationType::from(&WriteGetObjectResponse), false));
                }
                Err(super::unknown_operation())
            }
            S3Path::Object { .. } => {
                if let Some(qs) = qs {
                    if qs.has("select") && super::check_query_pattern(qs, "select-type", "2") {
                        return Ok((OperationType::from(&SelectObjectContent), true));
                    }
                    if qs.has("uploads") {
                        return Ok((OperationType::from(&CreateMultipartUpload), false));
                    }
                    if qs.has("restore") {
                        return Ok((OperationType::from(&RestoreObject), true));
                    }
                }
                if let Some(qs) = qs {
                    if qs.has("uploadId") {
                        return Ok((OperationType::from(&CompleteMultipartUpload), true));
                    }
                }
                Err(super::unknown_operation())
            }
        },
        hyper::Method::PUT => match s3_path {
            S3Path::Root => Err(super::unknown_operation()),
            S3Path::Bucket { .. } => {
                if let Some(qs) = qs {
                    if qs.has("analytics") {
                        return Ok((OperationType::from(&PutBucketAnalyticsConfiguration), true));
                    }
                    if qs.has("intelligent-tiering") {
                        return Ok((OperationType::from(&PutBucketIntelligentTieringConfiguration), true));
                    }
                    if qs.has("inventory") {
                        return Ok((OperationType::from(&PutBucketInventoryConfiguration), true));
                    }
                    if qs.has("metrics") {
                        return Ok((OperationType::from(&PutBucketMetricsConfiguration), true));
                    }
                    if qs.has("accelerate") {
                        return Ok((OperationType::from(&PutBucketAccelerateConfiguration), true));
                    }
                    if qs.has("acl") {
                        return Ok((OperationType::from(&PutBucketAcl), true));
                    }
                    if qs.has("cors") {
                        return Ok((OperationType::from(&PutBucketCors), true));
                    }
                    if qs.has("encryption") {
                        return Ok((OperationType::from(&PutBucketEncryption), true));
                    }
                    if qs.has("lifecycle") {
                        return Ok((OperationType::from(&PutBucketLifecycleConfiguration), true));
                    }
                    if qs.has("logging") {
                        return Ok((OperationType::from(&PutBucketLogging), true));
                    }
                    if qs.has("notification") {
                        return Ok((OperationType::from(&PutBucketNotificationConfiguration), true));
                    }
                    if qs.has("ownershipControls") {
                        return Ok((OperationType::from(&PutBucketOwnershipControls), true));
                    }
                    if qs.has("policy") {
                        return Ok((OperationType::from(&PutBucketPolicy), true));
                    }
                    if qs.has("replication") {
                        return Ok((OperationType::from(&PutBucketReplication), true));
                    }
                    if qs.has("requestPayment") {
                        return Ok((OperationType::from(&PutBucketRequestPayment), true));
                    }
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&PutBucketTagging), true));
                    }
                    if qs.has("versioning") {
                        return Ok((OperationType::from(&PutBucketVersioning), true));
                    }
                    if qs.has("website") {
                        return Ok((OperationType::from(&PutBucketWebsite), true));
                    }
                    if qs.has("object-lock") {
                        return Ok((OperationType::from(&PutObjectLockConfiguration), true));
                    }
                    if qs.has("publicAccessBlock") {
                        return Ok((OperationType::from(&PutPublicAccessBlock), true));
                    }
                }
                Ok((OperationType::from(&CreateBucket), true))
            }
            S3Path::Object { .. } => {
                if let Some(qs) = qs {
                    if qs.has("acl") {
                        return Ok((OperationType::from(&PutObjectAcl), true));
                    }
                    if qs.has("legal-hold") {
                        return Ok((OperationType::from(&PutObjectLegalHold), true));
                    }
                    if qs.has("retention") {
                        return Ok((OperationType::from(&PutObjectRetention), true));
                    }
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&PutObjectTagging), true));
                    }
                }
                if let Some(qs) = qs {
                    if qs.has("uploadId") && req.headers.contains_key("x-amz-copy-source") {
                        return Ok((OperationType::from(&UploadPartCopy), false));
                    }
                }
                if let Some(qs) = qs {
                    if qs.has("uploadId") {
                        return Ok((OperationType::from(&UploadPart), false));
                    }
                }
                if req.headers.contains_key("x-amz-copy-source") {
                    return Ok((OperationType::from(&CopyObject), false));
                }
                Ok((OperationType::from(&PutObject), false))
            }
        },
        hyper::Method::DELETE => match s3_path {
            S3Path::Root => Err(super::unknown_operation()),
            S3Path::Bucket { .. } => {
                if let Some(qs) = qs {
                    if qs.has("analytics") {
                        return Ok((OperationType::from(&DeleteBucketAnalyticsConfiguration), false));
                    }
                    if qs.has("intelligent-tiering") {
                        return Ok((OperationType::from(&DeleteBucketIntelligentTieringConfiguration), false));
                    }
                    if qs.has("inventory") {
                        return Ok((OperationType::from(&DeleteBucketInventoryConfiguration), false));
                    }
                    if qs.has("metrics") {
                        return Ok((OperationType::from(&DeleteBucketMetricsConfiguration), false));
                    }
                    if qs.has("cors") {
                        return Ok((OperationType::from(&DeleteBucketCors), false));
                    }
                    if qs.has("encryption") {
                        return Ok((OperationType::from(&DeleteBucketEncryption), false));
                    }
                    if qs.has("lifecycle") {
                        return Ok((OperationType::from(&DeleteBucketLifecycle), false));
                    }
                    if qs.has("ownershipControls") {
                        return Ok((OperationType::from(&DeleteBucketOwnershipControls), false));
                    }
                    if qs.has("policy") {
                        return Ok((OperationType::from(&DeleteBucketPolicy), false));
                    }
                    if qs.has("replication") {
                        return Ok((OperationType::from(&DeleteBucketReplication), false));
                    }
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&DeleteBucketTagging), false));
                    }
                    if qs.has("website") {
                        return Ok((OperationType::from(&DeleteBucketWebsite), false));
                    }
                    if qs.has("publicAccessBlock") {
                        return Ok((OperationType::from(&DeletePublicAccessBlock), false));
                    }
                }
                Ok((OperationType::from(&DeleteBucket), false))
            }
            S3Path::Object { .. } => {
                if let Some(qs) = qs {
                    if qs.has("tagging") {
                        return Ok((OperationType::from(&DeleteObjectTagging), false));
                    }
                }
                if let Some(qs) = qs {
                    if qs.has("uploadId") {
                        return Ok((OperationType::from(&AbortMultipartUpload), false));
                    }
                }
                Ok((OperationType::from(&DeleteObject), false))
            }
        },
        _ => Err(super::unknown_operation()),
    }
}
