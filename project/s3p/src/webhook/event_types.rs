use std::{fmt, str::FromStr};

use serde::{de::Visitor, Deserialize, Serialize};

use strum_macros::{EnumDiscriminants, EnumString};
use thiserror::Error;

// Webhook accepts POST with JSON https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-content-structure.html
// <<< Generated by https://transform.tools/json-to-rust-serde

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct S3WebhookEvent {
    #[serde(rename = "Records")]
    pub records: Vec<Record>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Record {
    pub event_version: String,
    pub event_source: String,
    pub aws_region: String,
    pub event_time: String,
    #[serde(rename = "eventName")]
    pub event_type: S3EventType,
    pub user_identity: UserIdentity,
    pub request_parameters: RequestParameters,
    pub response_elements: ResponseElements,
    pub s3: S3,
    pub glacier_event_data: Option<GlacierEventData>, // optional
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UserIdentity {
    pub principal_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RequestParameters {
    #[serde(rename = "sourceIPAddress")]
    pub source_ipaddress: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ResponseElements {
    #[serde(rename = "x-amz-request-id")]
    pub x_amz_request_id: String,
    #[serde(rename = "x-amz-id-2")]
    pub x_amz_id_2: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct S3 {
    #[serde(rename = "s3SchemaVersion")]
    pub s3schema_version: String,
    pub configuration_id: String,
    pub bucket: Bucket,
    pub object: Object,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Bucket {
    pub name: String,
    pub owner_identity: OwnerIdentity,
    pub arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OwnerIdentity {
    pub principal_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Object {
    pub key: String,
    pub size: u64, // generated version put string here
    pub e_tag: String,
    pub version_id: String,
    pub sequencer: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GlacierEventData {
    pub restore_event_data: RestoreEventData,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RestoreEventData {
    pub lifecycle_restoration_expiry_time: String,
    pub lifecycle_restore_storage_class: String,
}

// >>> Generated by https://transform.tools/json-to-rust-serde

#[derive(Default, Debug, Clone, PartialEq, Serialize, EnumDiscriminants)]
#[strum_discriminants(derive(EnumString))]
pub enum S3EventType {
    #[default]
    TestEvent,
    ObjectCreated(ObjectCreatedEvent),
    ObjectRemoved(ObjectRemovedEvent),
    ObjectRestore(ObjectRestoreEvent),
    ObjectReplication(ObjectReplicationEvent),
    ReducedRedundancyLostObject,
    LifecycleTransition,
    LifecycleExpiration(LifecycleExpirationEvent),
    IntelligentTiering,
    ObjectTagging(ObjectTaggingEvent),
    ObjectAcl(ObjectAclEvent),
}

#[derive(Error, Debug)]
pub(crate) enum TypeParseError {
    #[error("missing variant")]
    MissingVariant,
    #[error("parse error")]
    ParseError(#[from] strum::ParseError),
}

trait ParseEnumExt: Sized {
    fn from_opt_str(name: Option<&str>) -> Result<Self, TypeParseError>;
}

impl<T: std::str::FromStr<Err = strum::ParseError>> ParseEnumExt for T {
    fn from_opt_str(name: Option<&str>) -> Result<Self, TypeParseError> {
        let name = name.ok_or(TypeParseError::MissingVariant)?;

        Self::from_str(name).map_err(TypeParseError::from)
    }
}

impl S3EventType {
    pub(crate) fn from_str2(
        type_name: &str,
        variant: Option<&str>,
    ) -> Result<Self, TypeParseError> {
        type TName = S3EventTypeDiscriminants;

        Ok(
            match TName::from_str(type_name).map_err(TypeParseError::from)? {
                TName::TestEvent => S3EventType::TestEvent,
                TName::ObjectCreated => {
                    S3EventType::ObjectCreated(ObjectCreatedEvent::from_opt_str(variant)?)
                }
                TName::ObjectRemoved => {
                    S3EventType::ObjectRemoved(ObjectRemovedEvent::from_opt_str(variant)?)
                }
                TName::ObjectRestore => {
                    S3EventType::ObjectRestore(ObjectRestoreEvent::from_opt_str(variant)?)
                }
                TName::ObjectReplication => {
                    S3EventType::ObjectReplication(ObjectReplicationEvent::from_opt_str(variant)?)
                }
                TName::ReducedRedundancyLostObject => S3EventType::ReducedRedundancyLostObject,
                TName::LifecycleTransition => S3EventType::LifecycleTransition,
                TName::LifecycleExpiration => S3EventType::LifecycleExpiration(
                    LifecycleExpirationEvent::from_opt_str(variant)?,
                ),
                TName::IntelligentTiering => S3EventType::IntelligentTiering,
                TName::ObjectTagging => {
                    S3EventType::ObjectTagging(ObjectTaggingEvent::from_opt_str(variant)?)
                }
                TName::ObjectAcl => S3EventType::ObjectAcl(ObjectAclEvent::from_opt_str(variant)?),
            },
        )
    }
}

impl<'de> Deserialize<'de> for S3EventType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct EventTypeVisitor;

        impl<'de> Visitor<'de> for EventTypeVisitor {
            type Value = S3EventType;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("Event name with shape TYPE:VARIANT")
            }

            fn visit_str<E>(self, name: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                let (type_name, variant) = name
                    .split_once(':')
                    .map(|(name, variant)| (name, Some(variant)))
                    .unwrap_or((name, None));

                // Type alias for readability
                S3EventType::from_str2(type_name, variant).map_err(|e| E::custom(e))
            }
        }

        deserializer.deserialize_str(EventTypeVisitor)
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectCreatedEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    Put,
    Post,
    Copy,
    CompleteMultipartUpload,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectRemovedEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    Delete,
    DeleteMarkerCreated,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectRestoreEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    Post,
    Completed,
    Delete,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectReplicationEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    OperationFailedReplication,
    OperationMissedThreshold,
    OperationReplicatedAfterThreshold,
    OperationNotTracked,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum LifecycleExpirationEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    Delete,
    DeleteMarkerCreated,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectTaggingEvent {
    #[default]
    #[strum(serialize = "*")]
    Any,
    Put,
    Delete,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize, EnumString)]
pub enum ObjectAclEvent {
    #[default]
    Put,
}

#[cfg(test)]
mod tests {
    use ctor::ctor;
    use miette::{IntoDiagnostic, Result};
    use tracing::debug;

    use super::*;

    #[ctor]
    fn prepare() {
        let _ = crate::try_init_tracing();
    }

    #[test]
    fn parse_webhook_json() -> Result<()> {
        let json = r###"
        {  
            "Records":[  
               {  
                  "eventVersion":"2.1",
                  "eventSource":"aws:s3",
                  "awsRegion":"us-west-2",
                  "eventTime":"1970-01-01T00:00:00.000Z",
                  "eventName":"ObjectCreated:Put",
                  "userIdentity":{  
                     "principalId":"AIDAJDPLRKLG7UEXAMPLE"
                  },
                  "requestParameters":{  
                     "sourceIPAddress":"127.0.0.1"
                  },
                  "responseElements":{  
                     "x-amz-request-id":"C3D13FE58DE4C810",
                     "x-amz-id-2":"FMyUVURIY8/IgAtTv8xRjskZQpcIZ9KG4V5Wp6S7S/JRWeUWerMUE5JgHvANOjpD"
                  },
                  "s3":{  
                     "s3SchemaVersion":"1.0",
                     "configurationId":"testConfigRule",
                     "bucket":{  
                        "name":"mybucket",
                        "ownerIdentity":{  
                           "principalId":"A3NL1KOZZKExample"
                        },
                        "arn":"arn:aws:s3:::mybucket"
                     },
                     "object":{  
                        "key":"HappyFace.jpg",
                        "size":1024,
                        "eTag":"d41d8cd98f00b204e9800998ecf8427e",
                        "versionId":"096fKKXTRTtl3on89fVO.nfljtsv6qko",
                        "sequencer":"0055AED6DCD90281E5"
                     }
                  }
               }
            ]
         }
        "###;

        let de = serde_json::from_str::<S3WebhookEvent>(json).into_diagnostic()?;

        debug!("{:#?}", de);

        Ok(())
    }
}
